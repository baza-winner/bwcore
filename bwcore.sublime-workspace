{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Mus",
				"MustCmdOpt\tfunc(a bwval.FromProvider) bwexec.CmdOpt ·ƒ"
			],
			[
				"opt",
				"optOpt\t[]O ·ν"
			],
			[
				"ValMap",
				"ValMapIntf\tValKind ·Ɩ"
			],
			[
				"Keys",
				"KeysFilter\tfunc(key string) bool ·ʈ"
			],
			[
				"file",
				"fileSpec\tstring ·ν"
			],
			[
				"Re",
				"ReplaceAllStringFunc\tfunc(src string, repl func(string) string) string ·ƒ"
			],
			[
				"pri",
				"printCases\t[]printCase ·ν"
			],
			[
				"pric",
				"printCases\t[]printCase ·ν"
			],
			[
				"K",
				"KeyForPathS\tfunc() string ·ƒ"
			],
			[
				"Sp",
				"Sprintf\tfunc(format string, a ...interface{}) string ·ƒ"
			],
			[
				"ne",
				"needQuote\tbool ·ν"
			],
			[
				"Par",
				"ParseValByDef\tfunc(p bwparse.I, def Def, optBase ...bw.ValPath) interface{}, bwparse.Status ·ƒ"
			],
			[
				"iot",
				"ioutil\tpackage ·ρ"
			],
			[
				"Pani",
				"PanicErr\tfunc(err error, optDepth ...uint) ·ƒ"
			],
			[
				"From",
				"FromTemplate\tfunc(template Template, optVars ...map[string]interface{}) interface{}, error ·ƒ"
			],
			[
				"Temp",
				"TemplateFrom\tfunc(pp bwrune.ProviderProvider) Template ·ƒ"
			],
			[
				"tes",
				"testOpt\tinterface ·ν"
			],
			[
				"typ",
				"typeOf\treflect.Type ·ν"
			],
			[
				"prefix",
				"prefixArgs\t[]interface{} ·ν"
			],
			[
				"fmt",
				"fmtArgs\t[]interface{} ·ν"
			],
			[
				"fun",
				"function\tuintptr ·ν"
			],
			[
				"val",
				"ValChecker\tinterface ·ʈ"
			],
			[
				"V",
				"VarValue\tinterface ·ν"
			],
			[
				"Var",
				"VarPathStr\tstring ·ν"
			],
			[
				"type",
				"typedArg\tVarIs ·ν"
			],
			[
				"t",
				"typedArg\tUnicodeCategory ·ν"
			],
			[
				"Ma",
				"MustVarPathFrom\tfunc(s string) VarPath ·ƒ"
			],
			[
				"get",
				"getVarValue\tfunc(varPath VarPath) VarValue ·ƒ"
			],
			[
				"P",
				"RunePtrStructs\t[]RunePtrStruct ·ʈ"
			],
			[
				"Run",
				"RunePtrStruct\tstruct ·ʈ"
			],
			[
				"pre",
				"preLineCount\tint ·ν"
			],
			[
				"pu",
				"pushRune\tfunc() ·ƒ"
			],
			[
				"rune",
				"runePtr\t*rune ·ν"
			],
			[
				"cha",
				"charPtr\t*rune ·ν"
			],
			[
				"string",
				"stringCharProvider\tstruct ·ʈ"
			],
			[
				"item",
				"itemType\tparseStackItemType ·ν"
			],
			[
				"stack",
				"stackSubItem\tparseStackItem ·ν"
			],
			[
				"def",
				"defaultValue\t[]interface{} ·ν"
			],
			[
				"Con",
				"ConfigState\tstruct ·ʈ"
			],
			[
				"A",
				"ArrayOf\tdeftype.Item ·Ɩ"
			],
			[
				"FromS",
				"FromArgs\tfunc(kk ...deftype.Item) deftype.Set ·ƒ"
			],
			[
				"max",
				"maxNumber\t*float64 ·ν"
			],
			[
				"min",
				"minNumber\t*float64 ·ν"
			],
			[
				"Ar",
				"Array\tdeftype.Item ·Ɩ"
			],
			[
				"limi",
				"limitValue\tinvalid type ·ν"
			],
			[
				"value",
				"valueErrorMake\tfunc(v value, errorType valueErrorType, args ...interface{}) valueError ·ƒ"
			],
			[
				"_mu",
				"_mustBeInt64\tfunc(v interface{}) int64 ·ƒ"
			],
			[
				"Arr",
				"ArrayOf\tdeftype.Item ·Ɩ"
			],
			[
				"elemVal",
				"elemValIntf\tinterface ·ν"
			],
			[
				"Item_",
				"Item_below_\tdeftype.Item ·Ɩ"
			],
			[
				"valKe",
				"valKeyValIntf\tinterface ·ν"
			],
			[
				"co",
				"compileDefResult\t*Def ·ν"
			],
			[
				"Flo",
				"Float64\treflect.Kind ·Ɩ"
			],
			[
				"MaxInt",
				"MaxInt64\tint64 ·Ɩ"
			],
			[
				"Ui",
				"Uint32\treflect.Kind ·Ɩ"
			],
			[
				"Uint",
				"Uint16\treflect.Kind ·Ɩ"
			],
			[
				"U",
				"Uint8\treflect.Kind ·Ɩ"
			],
			[
				"valu",
				"valueErrorMake\tfunc(v value, errorType valueErrorType, args ...interface{}) valueError ·ƒ"
			],
			[
				"Pre",
				"PrettyJson\tfunc(v interface{}) string ·ƒ"
			],
			[
				"Pr",
				"PrettyJson\tfunc(v interface{}) string ·ƒ"
			],
			[
				"_mus",
				"_mustBeString\tfunc(v interface{}) string ·ƒ"
			],
			[
				"fm",
				"fmtString\tstring ·ν"
			],
			[
				"ofType",
				"ofTypeStrings\t[]string ·ν"
			],
			[
				"ofTy",
				"ofTypeArray\t[]string ·ν"
			],
			[
				"default",
				"defaultValueIntf\tinterface ·ν"
			],
			[
				"errHa",
				"errHasUnexpectedKeys\tfunc(unexpectedKeys []string) ·ƒ"
			],
			[
				"valueha",
				"valueHasUnexpectedKeysError\tvalueError ·Ɩ"
			],
			[
				"defKeys",
				"defKeysKey\tstring ·ν"
			],
			[
				"va",
				"valMap\tmap[string]interface{} ·ν"
			],
			[
				"where",
				"whereVal\tstring ·ν"
			],
			[
				"int",
				"interface"
			],
			[
				"defKey",
				"defKeysKeyValue"
			],
			[
				"some",
				"somewhere"
			],
			[
				"vali",
				"validateType"
			],
			[
				"exp",
				"expectedKeys"
			],
			[
				"whe",
				"whereStruct"
			],
			[
				"valid",
				"validFields"
			],
			[
				"keyValue",
				"keyValueType"
			],
			[
				"wher",
				"where"
			],
			[
				"is",
				"isRequired"
			],
			[
				"_get",
				"_getValidatedTypeValueOfHashKey"
			],
			[
				"sca",
				"scalar"
			],
			[
				"sub",
				"subType"
			],
			[
				"ex",
				"expectedTypes"
			],
			[
				"exis",
				"exists"
			],
			[
				"su",
				"suffix"
			],
			[
				"str",
				"structValue"
			],
			[
				"exi",
				"exists"
			],
			[
				"exit",
				"exitOnError"
			],
			[
				"all",
				"allSeparate"
			],
			[
				"el",
				"elsif"
			],
			[
				"array",
				"arrayItem"
			],
			[
				"ar",
				"array"
			],
			[
				"no",
				"normalize"
			],
			[
				"arr",
				"arrayItem"
			],
			[
				"forc",
				"forceRecreate"
			],
			[
				"dockerIma",
				"dockerImageName"
			],
			[
				"ngi",
				"nginx"
			],
			[
				"temp",
				"templateFileSpec"
			],
			[
				"var",
				"varSubstSub"
			],
			[
				"commen",
				"commentSuffix"
			],
			[
				"sep",
				"separatorLine"
			],
			[
				"git",
				"gitignore"
			],
			[
				"ima",
				"imageId"
			],
			[
				"et",
				"etaImageId"
			],
			[
				"err",
				"errorCode"
			],
			[
				"retu",
				"returnCode"
			],
			[
				"por",
				"portNameByValue"
			],
			[
				"bas",
				"basePorts"
			],
			[
				"ke",
				"camelCaseToKebabCase"
			],
			[
				"by",
				"byName"
			],
			[
				"op",
				"options"
			],
			[
				"en",
				"entityName"
			],
			[
				"_de",
				"_debugVar"
			],
			[
				"_sho",
				"_shortenFileSpec"
			],
			[
				"forceRecreateA",
				"forceRecreateAndCleanMappedVolumesDef"
			],
			[
				"_is",
				"_isInDocker"
			],
			[
				"BW_",
				"BW_SELF_UPDATE_SOURCE"
			],
			[
				"_bwPro",
				"_bwProjShortcut"
			],
			[
				"баз",
				"базовых"
			],
			[
				"см",
				"смещение"
			],
			[
				"proj",
				"projShortcut"
			],
			[
				"projSh",
				"projShortcut"
			],
			[
				"OPT_",
				"OPT_uninstall"
			],
			[
				"gitO",
				"gitOriginHolder"
			],
			[
				"projD",
				"projDir"
			],
			[
				"prof",
				"profileLineRegExp"
			],
			[
				"perl",
				"perlCode"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "%YAML 1.2\n---\nname: JLF\n# See http://www.sublimetext.com/docs/3/syntax.html\nfile_extensions: [ jlf ]\nscope: source.jlf\n\nvariables:\n  space: '[\\s]+'\n  beginOfSingleLineComment: '//'\n  beginOfMultiLineComment: '/\\*'\n  endOfMultiLineComment: '\\*/'\n\n  any: '(?=.)'\n\n  number: '[\\+\\-]?\\d+(?:\\.\\d+)?'\n  id: '[a-zA-Z_]([a-zA-Z_\\d\\.-]*)'\n  bool: true|false\n  nil: nil\n\n  keySeparator: '(\\s[=-]>|\\s=|:)?(\\s|$)'\n  commaSeparatorOptional: ','\n\n  beginOfMap: '\\{'\n  endOfMap: '\\}'\n\n  beginOfArray: '\\['\n  endOfArray: '\\]'\n\n  beginOfVarDefBlock: '\\('\n  endOfVarDefBlock: '\\)'\n  beginOfExpr: '\\('\n  endOfExpr: '\\)'\n  beginOfStringSubExpr: '<'\n  endOfStringSubExpr: '>'\n\n  beginOfArgsMap: '\\{'\n  endOfArgsMap: '\\}'\n\n  beginOfArgsArray: '\\{'\n  endOfArgsArray: '\\}'\n\n  beginOfIterator: '\\['\n  endOfIterator: '\\]'\n\n  quotedStringDelimiter: '\"'\n  regexpStringDelimiter: '/'\n\n  escapeStarter: '\\\\'\n  varStarter: '\\$'\n  fileSpecStarter: '%'\n  defStarter: '\\bDef\\b'\n  genStarter: \\bGen\\b\n  colon: ':'\n  chainSegmentSpecStarter: '[^^\\s\\(\\|\\*%]'\n\n  int: '[-+]?\\d+'\n\n  pathSegmentSeparator: '\\|'\n  rangeSeparator: '\\.\\.'\n  negationMark: '!'\n\n  ternaryIf: '\\?'\n  ternaryDelimiter: ':'\n\n  spaceAfter: '(\\s|$)'\n  sumOps: '[\\+\\-]'\n  mulOps: '[\\*\\/]'\n  andOp: '(\\&\\&)'\n  orOp: '(\\|\\|)'\n  cmpOps: '(==|!=|<=|>=)'\n  matchOp: '(=~)'\n\n  keysDef: \\bKeysDef\\b\n  defTypeSingleSimple: \\bAny|Null|Nil\\b\n  genType: \\bArray|{{keysDef}}|Map|String|Int|Number|Bool|Range|Def|Gen\\b\n  defTypeSingleComplex: \\b{{genType}}|Func\\b\n  defTypeSingle: '{{defTypeSingleComplex}}|{{keysDef}}|{{defTypeSingleSimple}}'\n  defTypeMulti: '\\bArrayOf|AnyBut\\b'\n  spreadOp: '(\\.\\.\\.)'\n\n  optionalEnder: '\\?'\n  mustEnder: '!'\n  pathDefaultValueStarter: ':'\n  beginOfNonQuotedKey: '(?=[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparatorOptional}}])(?!{{endOfNonQuotedKey}})'\n  endOfNonQuotedKey: '{{space}}|{{optionalEnder}}|{{beginOfExpr}}|{{endOfExpr}}|{{beginOfMap}}|{{beginOfArray}}|{{endOfArray}}|{{keySeparator}}'\n  beginOfNonQuotedString: '(?=[\\\\a-zA-Z_\\.])'\n  endOfNonQuotedString: '{{space}}|{{optionalEnder}}|{{beginOfExpr}}|{{endOfExpr}}|{{endOfStringSubExpr}}|{{pathSegmentSeparator}}|{{beginOfMap}}|{{beginOfArray}}|{{endOfMap}}|{{endOfArray}}|{{commaSeparatorOptional}}|{{defStarter}}|{{spreadOp}}'\n  jsonQuotedEscapeRunes: '[bfnrt]'\n  jsonQuotedEscapeRunesAsIs: '[\"\\\\/]'\n  escapeRunes: '[abfnrtv]'\n  nonQuotedKeyBegin: '[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparatorOptional}}]'\n  doubleQuotedValidRune: '\\x{0020}-\\x{10ffff}'\n\n# =============================================================================\n# =============================================================================\n\ncontexts:\n\n  prototype:\n    - include: spaceInclude\n\n  spaceInclude:\n    - meta_include_prototype: false\n    - match: '{{space}}'\n    - match: '{{beginOfSingleLineComment}}'\n      scope: punctuation.definition.comment.jlf\n      push:\n        - meta_include_prototype: false\n        - meta_scope: comment.line.jlf\n        - match: $\n          pop: true\n    - match: '{{beginOfMultiLineComment}}'\n      scope: punctuation.definition.comment.begin.jlf\n      push:\n        - meta_include_prototype: false\n        - meta_scope: comment\n        - match: '{{endOfMultiLineComment}}'\n          scope: punctuation.definition.comment.end.jlf\n          pop: true\n\n  illegalInclude:\n    - meta_include_prototype: false\n    - match: .\n      scope: invalid.illegal.jlf\n\n# =============================================================================\n\n  varDefInclude:\n    - match: '({{varStarter}})({{defStarter}})'\n      captures:\n        1: keyword.jlf\n        2: variable.parameter.jlf\n      push: [defValue, keySeparatorOptional]\n    - match: '({{varStarter}})'\n      scope: keyword.jlf\n      push: [value, keySeparatorOptional, varDefArgsOptional, varName]\n\n  main:\n    - match: '{{any}}'\n      set: [mainTail, mainArgsOptional]\n\n  mainArgsOptional:\n    - match: '({{varStarter}})(?={{beginOfArgsMap}})'\n      scope: keyword.jlf\n      set: varDefArgsOptional\n    - match: '{{any}}'\n      pop: true\n\n  mainTail:\n    - include: varDefInclude\n    - match: '{{any}}'\n      set: [end, value]\n\n  end:\n    - include: varDefInclude\n    - include: illegalInclude\n\n# =============================================================================\n\n  varDefArgsOptional:\n    - meta_include_prototype: false\n    - include: varDefArgsInclude\n    - match: '{{any}}'\n      pop: true\n\n  varDefArgsInclude:\n    - match: '{{beginOfArgsMap}}'\n      scope: punctuation.section.parens.begin.jlf\n      set:\n      - match: '{{endOfArgsMap}}'\n        scope: punctuation.section.block.end.jlf\n        pop: true\n      - match: '{{any}}'\n        push: varDefArgName\n        # push: [ commaSeparatorOptional, defValue, keySeparatorOptional, optionalKeyEnder, argName]\n\n  varDefArgName:\n    - match: '(?={{beginOfNonQuotedString}}|{{quotedStringDelimiter}}|{{regexpStringDelimiter}}|{{beginOfArray}})'\n      set: [defValue, keySeparatorOptional, optionalKeyEnder, varDefArgNameItem]\n    - match: '(?={{varStarter}}|{{beginOfExpr}})'\n      set: [keysDefSpreadOptional, commonValue]\n    - include: illegalInclude\n\n  varDefArgsValue:\n    - include: commonValueInclude\n    - include: varDefArgsInclude\n    - include: illegalInclude\n\n\n  argNameAtomInclude:\n    - include: regexpInclude\n    - include: argNameInclude\n\n  argNameInclude:\n    - match: '{{quotedStringDelimiter}}'\n      scope: punctuation.definition.string.begin.jlf\n      set:\n        - meta_include_prototype: false\n        - meta_scope: entity.name.variable.jlf\n        - include: quotedInclude\n    - match: '{{beginOfNonQuotedKey}}'\n      set:\n        - meta_include_prototype: false\n        - meta_scope: entity.name.variable.jlf\n        - match: '(?={{endOfNonQuotedKey}})'\n          pop: true\n        - match: '(\\\\){{endOfNonQuotedKey}}'\n          captures:\n            1: constant.character.escape.jlf\n        - include: escapeInclude\n\n  argName:\n    - include: argNameInclude\n    - include: illegalInclude\n\n  argNameAtom:\n    - include: argNameAtomInclude\n    - include: illegalInclude\n\n  varDefArgNameItem:\n    - match: '{{beginOfArray}}'\n      scope: punctuation.section.block.begin.jlf\n      set:\n        - match: '{{endOfArray}}'\n          scope: punctuation.section.block.end.jlf\n          pop: true\n        - match: '{{any}}'\n          push: [ commaSeparatorOptional, argNameAtom ]\n    - include: argNameAtomInclude\n    - include: illegalInclude\n\n# =============================================================================\n\n  genValue:\n    - include: commonValueInclude\n    - match: '{{any}}'\n      set: [gen, genStarterOptional]\n\n  genStarterOptional:\n    - match: '({{genStarter}})(?:({{colon}})(?=({{genType}})))?'\n      scope: comment.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  genInclude:\n    - meta_include_prototype: false\n    - match: '({{genStarter}})(?:({{colon}})(?=({{genType}})))?'\n      scope: keyword.jlf\n      set: gen\n\n  gen:\n    - meta_include_prototype: false\n    - match: '\\bMap\\b'\n      scope: variable.parameter.jlf\n      set:\n        - meta_include_prototype: false\n        - match: '({{beginOfMap}})'\n          set: [mapEnd, value, keySeparatorOptional, stringValue]\n        - include: illegalInclude\n    - match: '({{genType}})?'\n      scope: variable.parameter.jlf\n      set:\n        - meta_include_prototype: false\n        - match: '({{beginOfMap}})'\n          set:\n            - match: '{{endOfMap}}'\n              scope: punctuation.section.block.end.jlf\n              pop: true\n            - match: \\btype\\b\n              scope: keyword.jlf\n              push: [commaSeparatorOptional, genType, keySeparatorOptional]\n            - match: \\bkey\\b\n              scope: keyword.jlf\n              push: [commaSeparatorOptional, stringValue, keySeparatorOptional]\n            - match: \\bvalue\\b\n              scope: keyword.jlf\n              push: [commaSeparatorOptional, value, keySeparatorOptional]\n            - match: \\belem\\b\n              scope: keyword.jlf\n              push: [commaSeparatorOptional, gen, keySeparatorOptional]\n            - include: illegalInclude\n        - include: illegalInclude\n    - include: illegalInclude\n\n  genType:\n    - match: \\b{{defTypeSingle}}\\b\n      scope: variable.parameter.jlf\n      pop: true\n\n# =============================================================================\n\n  iteratorNegationOptional:\n    - meta_include_prototype: false\n    - match: '{{negationMark}}'\n      scope: keyword.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  iteratorConditionOptional:\n    - match: '{{int}}'\n      scope: constant.numeric.jlf\n      set: rangeTailOptinal\n    - match: '{{beginOfExpr}}'\n      scope: punctuation.section.parens.begin.jlf\n      set: [rangeTailOptinal, exprEnd, expr]\n    - include: stringInclude\n    - match: '{{any}}'\n      pop: true\n\n  iteratorEnd:\n    - meta_include_prototype: false\n    - match: '{{endOfIterator}}'\n      scope: punctuation.section.bracket.begin.jlf\n      set:\n        - meta_include_prototype: false\n        - match: '{{beginOfIterator}}'\n          scope: punctuation.section.bracket.begin.jlf\n          set: [iteratorEnd, iteratorConditionOptional, iteratorNegationOptional]\n        - match: '{{any}}'\n          set: genValue\n    - include: illegalInclude\n\n# =============================================================================\n\n  varSpecChainInclude:\n    - meta_include_prototype: false\n    - match: '(?={{varStarter}})'\n      set: [chainNextSegmentOptional, varSpec]\n\n  varSpecChain:\n    - include: varSpecChainInclude\n    - include: illegalInclude\n\n  chainNextSegmentOptional:\n    # - meta_include_prototype: false\n    - match: '{{pathSegmentSeparator}}'\n      scope: keyword.jlf\n      push: chainSegmentSpec\n    - match: '{{any}}'\n      pop: true\n\n  varSpec:\n    - meta_include_prototype: false\n    - include: varSpecInclude\n\n  chainSegmentSpec:\n    - match: '(?={{defStarter}})'\n      set: [chainNextSegmentOptional, defWithStarter]\n    - match: '{{beginOfIterator}}'\n      scope: punctuation.section.bracket.begin.jlf\n      set: [chainNextSegmentOptional, iteratorEnd, iteratorConditionOptional, iteratorNegationOptional]\n    - include: intInclude\n    - include: exprInclude\n    - include: varSpecInclude\n    - match: '{{optionalEnder}}|{{mustEnder}}'\n      scope: entity.name.label.jlf\n      pop: true\n    - match: '{{quotedStringDelimiter}}'\n      scope: punctuation.definition.string.begin.jlf\n      set:\n        - meta_include_prototype: false\n        - meta_scope: support.function.jlf\n        - include: quotedInclude\n    - match: '{{chainSegmentSpecStarter}}'\n      set:\n        - meta_include_prototype: false\n        - meta_scope: support.function.jlf\n        - include: nonQuotedStringTailInclude\n    - include: illegalInclude\n\n# =============================================================================\n\n  varSpecInclude:\n    - meta_include_prototype: false\n    - match: '({{varStarter}})'\n      scope: keyword.jlf\n      set: [varArgsOptional, varName]\n\n  varChainInclude:\n    - meta_include_prototype: false\n    - match: '({{varStarter}})'\n      scope: keyword.jlf\n      set: [chainNextSegmentOptional, varArgsOptional, varName]\n\n  varName:\n    - meta_include_prototype: false\n    - match: '(_|Key|Idx|ElemOf|Len|File|Ref|\\.\\.|\\.)(?={{endOfNonQuotedString}})'\n      scope: entity.name.label.jlf\n      pop: true\n    - match: '(?={{endOfNonQuotedString}})'\n      set: illegalInclude\n    - match: '{{any}}'\n      set:\n        - meta_include_prototype: false\n        - clear_scopes: true\n        - meta_scope: entity.name.variable.jlf\n        - include: nonQuotedStringTailInclude\n\n  varArgsOptional:\n    - meta_include_prototype: false\n    - match: '{{beginOfMap}}'\n      scope: punctuation.section.block.begin.jlf\n      set:\n        - match: '{{endOfMap}}'\n          scope: punctuation.section.block.end.jlf\n          pop: true\n        - match: '{{any}}'\n          push: [commaSeparatorOptional, value, keySeparatorOptional, argName]\n    - include: arrayInclude\n    - include: exprInclude\n    - match: '{{any}}'\n      pop: true\n\n  specInclude:\n    - meta_include_prototype: false\n    - include: varSpecArgsInclude\n    - include: nonQuotedStringTailInclude\n\n# =============================================================================\n\n  exprInclude:\n    - meta_include_prototype: false\n    - match: '{{beginOfExpr}}'\n      scope: punctuation.section.parens.begin.jlf\n      set: [exprEnd,  exprContent]\n\n  exprContent:\n    - match: '{{negationMark}}'\n      set: [exprTernaryBeginOptional, boolExprTailOptional, valueChain]\n    - match: '{{any}}'\n      set: [exprTernaryBeginOptional, exprTailOptional, valueChain]\n\n  negationMarkOptional:\n    - meta_include_prototype: false\n    - match: '{{negationMark}}'\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  exprEnd:\n    - match: '{{endOfExpr}}'\n      scope: punctuation.section.parens.end.jlf\n      pop: true\n    - include: illegalInclude\n\n  expr:\n    - include: exprInclude\n    - include: illegalInclude\n\n  exprSumTailInclude:\n    - match: '{{sumOps}}{{spaceAfter}}'\n      set: [ exprSumTailOptional, valueChain ]\n\n  exprSumTailOptional:\n    - include: exprSumTailInclude\n    - match: '{{any}}'\n      pop: true\n\n  exprMulTailInclude:\n    - match: '{{mulOps}}{{spaceAfter}}'\n      set: [ exprMulTailOptional, valueChain ]\n\n  exprMulTailOptional:\n    - include: exprMulTailInclude\n    - match: '{{any}}'\n      pop: true\n\n  exprOrTailInclude:\n    - match: '{{orOp}}{{spaceAfter}}'\n      set: [ exprOrTailOptional, valueChain, negationMarkOptional]\n\n  exprOrTailOptional:\n    - include: exprOrTailInclude\n    - match: '{{any}}'\n      pop: true\n\n  exprAndTailInclude:\n    - match: '{{andOp}}{{spaceAfter}}'\n      set: [ exprAndTailOptional, valueChain, negationMarkOptional]\n\n  exprAndTailOptional:\n    - include: exprAndTailInclude\n    - match: '{{any}}'\n      pop: true\n\n  boolExprTailInclude:\n    - include: exprOrTailInclude\n    - include: exprAndTailInclude\n\n  boolExprTailOptional:\n    - include: boolExprTailInclude\n    - match: '{{any}}'\n      pop: true\n\n  exprTailOptional:\n    - include: exprSumTailInclude\n    - include: exprMulTailInclude\n    - match: '{{cmpOps}}{{spaceAfter}}'\n      scope: keyword.operator.logical.jlf\n      set: valueChain\n    - match: '{{matchOp}}{{spaceAfter}}'\n      scope: keyword.operator.logical.jlf\n      set: mathOpRhs\n    - include: boolExprTailInclude\n    - match: '{{any}}'\n      pop: true\n\n  mathOpRhs:\n    - include: defInclude\n    - include: regexpInclude\n    - include: commonValueInclude\n    - include: illegalInclude\n\n  exprTernaryBeginOptional:\n    - match: '{{ternaryIf}}{{ternaryDelimiter}}'\n      scope: keyword.jlf\n      push: valueWithoutTernary\n    - match: '{{ternaryIf}}'\n      scope: keyword.jlf\n      push: [valueWithoutTernary, exprTernaryDelimiter, valueWithoutTernary]\n    - match: '{{any}}'\n      pop: true\n\n  exprTernaryIf:\n    - match: '{{ternaryIf}}'\n      scope: keyword.jlf\n      pop: true\n    - include: illegalInclude\n\n  exprTernaryDelimiter:\n    - match: '{{ternaryDelimiter}}'\n      pop: true\n    - include: illegalInclude\n\n# =============================================================================\n\n  intInclude:\n    - match: '{{int}}'\n      scope: constant.numeric.jlf\n      pop: true\n\n# =============================================================================\n\n  escapeInclude:\n    - meta_include_prototype: false\n    - match: '(?=\\\\$)'\n      set:\n        - include: illegalInclude\n    - match: '\\\\{{escapeRunes}}'\n      scope: constant.character.escape.jlf\n    - match: '\\\\\"'\n      scope: constant.character.escape.jlf\n      push:\n        - match: '\"'\n          scope: constant.character.escape.jlf\n          pop: true\n    - match: '(\\\\).'\n      captures:\n        1: comment.jlf\n\n  stringSubExprInclude:\n    - meta_include_prototype: false\n    - match: '({{escapeStarter}})({{beginOfStringSubExpr}})'\n      scope: keyword.jlf\n      push: [stringSubExprEnd, exprContent]\n\n  nonQuotedStringTailInclude:\n    - meta_include_prototype: false\n    - include: stringSubExprInclude\n    # - match: '({{escapeStarter}})({{beginOfStringSubExpr}})'\n    #   scope: keyword.jlf\n    #   push: [stringSubExprEnd, exprContent]\n    - match: '(?={{endOfNonQuotedString}})'\n      pop: true\n    - match: '({{escapeStarter}}){{endOfNonQuotedString}}'\n      captures:\n        1: constant.character.escape.jlf\n    - include: escapeInclude\n\n  stringSubExprEnd:\n    - match: '{{endOfStringSubExpr}}'\n      scope: keyword.jlf\n      pop: true\n    - include: illegalInclude\n\n  stringHelperInclude:\n    - match: '{{escapeStarter}}u'\n      push:\n        - meta_scope: constant.character.escape.jlf\n        - match: '[0-9a-fA-F]{4}'\n          pop: true\n        - include: illegalInclude\n    - match: '{{escapeStarter}}{{jsonQuotedEscapeRunes}}'\n      scope: constant.character.escape.jlf\n    - match: '({{escapeStarter}})({{jsonQuotedEscapeRunesAsIs}})'\n      captures:\n        1: constant.character.escape.jlf\n    - match: '({{escapeStarter}})([{{doubleQuotedValidRune}}])'\n      captures:\n        1: comment.jlf\n\n  quotedInclude:\n    - meta_include_prototype: false\n    - include: stringHelperInclude\n    - match: '{{quotedStringDelimiter}}'\n      scope: punctuation.definition.string.end.jlf\n      pop: true\n    - match: '(?={{escapeStarter}}|[^{{doubleQuotedValidRune}}])'\n      set:\n        - include: illegalInclude\n\n  quotedStringInclude:\n    - meta_include_prototype: false\n    - match: '{{quotedStringDelimiter}}'\n      scope: punctuation.definition.string.begin.jlf\n      set:\n        - meta_include_prototype: false\n        - meta_scope: string.quoted.double.jlf\n        - include: stringSubExprInclude\n        - include: quotedInclude\n\n# =============================================================================\n\n  valueHelperInclude:\n    - match: '{{number}}'\n      scope: constant.numeric.jlf\n      set: rangeTailOptinal\n    - match: '(?={{beginOfExpr}})'\n      set: [rangeTailOptinal, expr]\n    - include: mapInclude\n    - include: defInclude\n    - include: keysDefInclude\n    - include: genInclude\n    - include: arrayInclude\n    - include: boolInclude\n    - include: nilInclude\n    - include: regexpInclude\n    - include: stringInclude\n\n  valueChainStart:\n    - include: varSpecInclude\n    - include: valueHelperInclude\n    - include: illegalInclude\n\n  valueChain:\n    - match: '{{any}}'\n      set: [chainNextSegmentOptional, valueChainStart]\n\n  valueWithoutTernary:\n    - match: '{{negationMark}}'\n      set: [boolExprTailOptional, valueChain]\n    - match: '{{any}}'\n      set: [exprTailOptional, valueChain]\n\n  value:\n    - include: varChainInclude\n    - include: valueHelperInclude\n    - include: illegalInclude\n\n# =====================================\n\n  regexpInclude:\n    - meta_include_prototype: false\n    - match: '{{regexpStringDelimiter}}'\n      # scope: punctuation.definition.string.begin.jlf\n      scope: keyword.jlf\n      set:\n        - meta_include_prototype: false\n        - meta_scope: string.quoted.double.jlf\n        - include: stringSubExprInclude\n        - include: stringHelperInclude\n        - match: '\\.'\n          scope: keyword.jlf\n        - match: '\\[\\['\n          scope: keyword.jlf\n          set: [asciiCharsetClassEnd, colon, asciiCharsetClass, charsetNegationOptional, colon]\n        - match: '\\['\n          scope: keyword.jlf\n          push:\n            - match: '\\]'\n              scope: keyword.jlf\n              pop: true\n            - match: '\\\\[dD]'\n              scope: keyword.jlf\n            - match: '\\\\p(\\w)'\n              captures:\n                1: keyword.jlf\n                2: entity.name.variable.jlf\n        - match: '\\?|\\+\\*'\n          scope: keyword.jlf\n        # - match: '\\*'\n        #   scope: keyword.jlf\n        - match: '({{regexpStringDelimiter}})([igm]*)'\n          scope: keyword.jlf\n          pop: true\n\n  colon:\n    - meta_include_prototype: false\n    - match: '{{colon}}'\n      scope: punctuation.delimiter.jlf\n      pop: true\n    - match: illegalInclude\n\n  charsetNegationOptional:\n    - meta_include_prototype: false\n    - match: '^'\n      scope: keyword.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  asciiCharsetClass:\n    - meta_include_prototype: false\n    - match: '\\balpha\\b'\n      scope: entity.name.variable.jlf\n      pop: true\n    - include: illegalInclude\n\n  asciiCharsetClassEnd:\n    - meta_include_prototype: false\n    - match: ']]'\n      scope: keyword.jlf\n      pop: true\n    - include: illegalInclude\n\n\n\n\n# =====================================\n\n  stringInclude:\n    - meta_include_prototype: false\n    - include: quotedStringInclude\n    - match: '{{beginOfNonQuotedString}}'\n      set:\n        - meta_include_prototype: false\n        - meta_scope: string.jlf\n        - include: nonQuotedStringTailInclude\n\n  stringValue:\n    - include: commonValueInclude\n    - include: stringInclude\n    - include: illegalInclude\n\n# =====================================\n\n  mapEnd:\n    - include: mapEndInclude\n    - include: illegalInclude\n\n  mapEndInclude:\n    - match: '{{endOfMap}}'\n      scope: punctuation.section.block.end.jlf\n      pop: true\n\n  mapInclude:\n    - meta_include_prototype: false\n    - match: '{{beginOfMap}}'\n      scope: punctuation.section.block.begin.jlf\n      set:\n        - include: mapEndInclude\n        - match: '(?={{varStarter}})'\n          push: [commaSeparatorOptional, optionalSpreadOptional, varSpec]\n        - match: '(?={{beginOfExpr}})'\n          push: [commaSeparatorOptional, optionalSpreadOptional, expr]\n        - match: '{{any}}'\n          push: [commaSeparatorOptional, value, keySeparatorOptional, optionalKeyEnder, key]\n\n  spreadOptional:\n    - meta_include_prototype: false\n    - match: '\\.\\.\\.'\n      scope: keyword.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  optionalSpreadOptional:\n    - meta_include_prototype: false\n    - match: '\\.\\.\\.'\n      scope: comment.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  key:\n    - match: '{{quotedStringDelimiter}}'\n      scope: punctuation.definition.string.begin.jlf\n      set:\n        - meta_include_prototype: false\n        - meta_scope: support.function.jlf\n        - include: quotedInclude\n    - match: '{{beginOfNonQuotedKey}}'\n      set:\n        - meta_include_prototype: false\n        - meta_scope: support.function.jlf\n        - match: '(?={{endOfNonQuotedKey}})'\n          pop: true\n        - match: '(\\\\){{endOfNonQuotedKey}}'\n          captures:\n            1: constant.character.escape.jlf\n        - include: escapeInclude\n    - include: illegalInclude\n\n  keySeparatorOptional:\n    - meta_include_prototype: false\n    - match: '{{keySeparator}}'\n      scope: comment.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  commaSeparatorOptional:\n    - match: '{{commaSeparatorOptional}}'\n      scope: comment.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n# =====================================\n\n  arrayInclude:\n    - meta_include_prototype: false\n    - match: '{{beginOfArray}}'\n      scope: punctuation.section.block.begin.jlf\n      set:\n        - match: '{{endOfArray}}'\n          scope: punctuation.section.block.end.jlf\n          pop: true\n        - match: '{{any}}'\n          push: [arrayIncludeHelper]\n\n  arrayIncludeHelper:\n    - match: '(?={{varStarter}})'\n      push: [spreadOptional, varSpec]\n    - match: '{{any}}'\n      push: [value]\n\n# =====================================\n\n  boolInclude:\n    - meta_include_prototype: false\n    - match: \\b{{bool}}\\b\n      scope: constant.language.jlf\n      pop: true\n\n# =====================================\n\n  nilInclude:\n    - meta_include_prototype: false\n    - match: \\b{{nil}}\\b\n      scope: constant.language.jlf\n      pop: true\n\n# =============================================================================\n\n  rangeValue:\n    - match: '{{number}}'\n      scope: constant.numeric.jlf\n      set:\n        - meta_include_prototype: false\n        - include: rangeTailInclude\n        - include: illegalInclude\n    - match: '(?={{varStarter}})'\n      set: [rangeTailOptinal, varSpecChain]\n    - match: '(?={{beginOfExpr}})'\n      set: [rangeTailOptinal, expr]\n    - include: illegalInclude\n\n  rangeTailOptinal:\n    - meta_include_prototype: false\n    - include: rangeTailInclude\n    - match: '{{any}}'\n      pop: true\n\n  rangeTailInclude:\n    - match: '{{rangeSeparator}}'\n      scope: keyword.jlf\n      set:\n        - meta_include_prototype: false\n        - match: '{{spaceAfter}}'\n          pop: true\n        - match: '{{any}}'\n          set: numberValue\n\n# =============================================================================\n\n  numberValue:\n    - include: commonValueInclude\n    - include: numberInclude\n    - include: illegalInclude\n\n  numberInclude:\n    - match: '{{number}}'\n      scope: constant.numeric.jlf\n      pop: true\n\n# =============================================================================\n\n  commonValueInclude:\n    - meta_include_prototype: false\n    - include: varSpecChainInclude\n    - include: exprInclude\n\n# =============================================================================\n\n  stringsInclude:\n    - match: '{{beginOfArray}}'\n      scope: punctuation.section.block.begin.jlf\n      set:\n        - match: '{{endOfArray}}'\n          scope: punctuation.section.block.end.jlf\n          pop: true\n        - match: '{{any}}'\n          push: [ commaSeparatorOptional, stringValue ]\n    - include: stringInclude\n\n  stringsValue:\n    - include: commonValueInclude\n    - include: stringsInclude\n    - include: illegalInclude\n\n# =============================================================================\n\n  defValue:\n    - include: commonValueInclude\n    - match: '{{any}}'\n      set: [def, defStarterOptional]\n\n  defStarterOptional:\n    - match: '({{defStarter}})(?:({{colon}})(?=({{genType}}|defTypeMulti)))?'\n      scope: comment.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n  defInclude:\n    - meta_include_prototype: false\n    - match: '({{defStarter}})(?:({{colon}})(?=({{genType}}|defTypeMulti)))?'\n      scope: keyword.jlf\n      set: def\n\n  defWithStarter:\n    - match: '(?={{defStarter}})'\n      set:\n        - include: defInclude\n    - include: illegalInclude\n\n  def:\n    - meta_include_prototype: false\n    - include: defAtomInclude\n    - match: '{{beginOfArray}}'\n      scope: punctuation.section.block.begin.jlf\n      set:\n        - match: '{{endOfArray}}'\n          pop: true\n        - match: '{{any}}'\n          push: [ commaSeparatorOptional, defAtom ]\n    - include: illegalInclude\n\n  defAtom:\n    - include: defAtomInclude\n    - include: illegalInclude\n\n  defAtomInclude:\n    - match: '\\bFunc\\b'\n      scope: variable.parameter.jlf\n      set: [ defValue, retPrefix, varDefArgsOptional]\n    - match: '({{defTypeSingleComplex}}|defTypeMulti)'\n      scope: variable.parameter.jlf\n      set:\n        - meta_include_prototype: false\n        - match: '{{beginOfMap}}'\n          scope: punctuation.section.block.begin.jlf\n          set: keyOfDef\n        - match: '{{any}}'\n          pop: true\n    - match: '{{defTypeSingleSimple}}'\n      scope: variable.parameter.jlf\n      pop: true\n    - match: '{{beginOfMap}}'\n      scope: punctuation.section.block.begin.jlf\n      set: keyOfDef\n\n  retPrefix:\n    - match: '->'\n      scope: keyword.jlf\n      pop: true\n    - match: illegalInclude\n\n  keyOfDef:\n    - match: '{{endOfMap}}'\n      scope: punctuation.section.block.end.jlf\n      pop: true\n    - match: \\btype\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, defTypeValue, keySeparatorOptional]\n    - match: \\bkeysDef\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, keysDefValue, keySeparatorOptional]\n    - match: \\b(enum|keys)\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, stringsValue, keySeparatorOptional]\n    - match: \\b(elemDef|arrayElemDef)\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, defValue, keySeparatorOptional]\n    - match: \\brange\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, rangeValue, keySeparatorOptional]\n    - match: \\bisOptional\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, boolValue, keySeparatorOptional]\n    - match: \\bdefault\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, value, keySeparatorOptional]\n    - match: \\barg\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, varDefArgsValue, keySeparatorOptional]\n    - match: \\bret\\b\n      scope: keyword.jlf\n      push: [commaSeparatorOptional, defValue, keySeparatorOptional]\n    - include: illegalInclude\n\n  defTypeValue:\n    - match: '{{defStarter}}'\n      scope: comment.jlf\n      set:\n        - meta_include_prototype: false\n        - include: defTypeInclude\n        - include: illegalInclude\n    - include: defTypeInclude\n    - include: illegalInclude\n\n  defTypeInclude:\n    - match: \\b{{defTypeSingle}}\\b\n      scope: variable.parameter.jlf\n      pop: true\n    - match: '{{beginOfArray}}'\n      scope: punctuation.section.block.begin.jlf\n      set:\n        - match: '{{endOfArray}}'\n          pop: true\n        - match: \\b{{defTypeMulti}}|{{defTypeSingle}}\\b\n          scope: variable.parameter\n        - include: illegalInclude\n\n# =============================================================================\n\n  keysDefInclude:\n    - match: '{{keysDef}}(?={{beginOfMap}})'\n      scope: keyword.jlf\n      set: keysDefValueInclude\n\n  keysDefValueInclude:\n    - match: '({{keysDef}})?({{beginOfMap}})'\n      captures:\n        1: comment.jlf\n        2: punctuation.section.block.begin.jlf\n      set:\n        - match: '{{endOfMap}}'\n          scope: punctuation.section.block.end.jlf\n          pop: true\n        - match: '{{any}}'\n          push: keysDefKey\n\n  keysDefValue:\n    - include: commonValueInclude\n    - include: keysDefValueInclude\n    - include: illegalInclude\n\n  keysDefKey:\n    - match: '(?={{beginOfNonQuotedString}}|{{quotedStringDelimiter}}|{{regexpStringDelimiter}}|{{beginOfArray}})'\n      set: [defValue, keySeparatorOptional, optionalKeyEnder, stringsOrRegexp]\n    - match: '(?={{varStarter}}|{{beginOfExpr}})'\n      set: [keysDefSpreadOptional, commonValue]\n    - include: illegalInclude\n\n  stringsOrRegexp:\n    - meta_include_prototype: false\n    - include: stringsValue\n    - include: regexpInclude\n    - include: illegalInclude\n\n  keysDefSpreadOptional:\n    - meta_include_prototype: false\n    - match: '{{spreadOp}}'\n      scope: keyword.jlf\n      pop: true\n    - match: '{{any}}'\n      set: [defValue, keySeparatorOptional, optionalKeyEnder]\n\n  commonValue:\n    - meta_include_prototype: false\n    - include: varSpecChainInclude\n    - include: exprInclude\n    - include: illegalInclude\n\n# =============================================================================\n\n  optionalKeyEnder:\n    - meta_include_prototype: false\n    - match: '({{optionalEnder}}|{{mustEnder}})'\n      scope: keyword.jlf\n      pop: true\n    - match: '{{any}}'\n      pop: true\n\n# =============================================================================\n\n  boolValue:\n    - include: commonValueInclude\n    - include: boolInclude\n    - include: illegalInclude\n\n# =============================================================================\n",
			"file": "jlf.sublime-syntax",
			"file_size": 31239,
			"file_write_time": 131919553719089090,
			"settings":
			{
				"buffer_size": 31239,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "jjjjjj",
			"settings":
			{
				"buffer_size": 6,
				"line_ending": "Unix",
				"name": "jjjjjj"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"pa",
				"Package Control: Install Package"
			],
			[
				"pack",
				"Package Control: Install Package"
			],
			[
				"packa",
				"Package Control: Remove Package"
			],
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"git",
				"Git: Status"
			],
			[
				"gi",
				"Git: Status"
			],
			[
				"g",
				"Git: Status"
			],
			[
				"ins",
				"Package Control: Install Package"
			],
			[
				"git:st",
				"Git: Status"
			],
			[
				"git:s",
				"Git: Status"
			],
			[
				"git:",
				"Git: Status"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"gitst",
				"Git: Status"
			],
			[
				"gits",
				"Git: Status"
			],
			[
				"git:sta",
				"Git: Status"
			],
			[
				"git bla",
				"Git: Blame"
			],
			[
				"git:stat",
				"Git: Status"
			],
			[
				"git: st",
				"Git: Status"
			],
			[
				"in",
				"Package Control: Install Package"
			],
			[
				"sublimelinter setting",
				"Preferences: SublimeLinter Settings – User"
			],
			[
				"vintage",
				"Package Control: Advanced Install Package"
			],
			[
				":w",
				":w - Save"
			]
		],
		"width": 428.0
	},
	"console":
	{
		"height": 150.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore"
	],
	"file_history":
	[
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwos/bwos.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwexec/bwexec.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bw/bw.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwval/bwval.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwtype/bwtype.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwexec/bwexec_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwexec/bwexectesthelper2/bwexectesthelper2.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwval/bwval_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwval/bwval_holder_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwval/bwval_holder.go",
		"/Users/yurybikuzin/Library/Application Support/Sublime Text 3/Packages/User/GoSublime/src/margo/margo.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwmap/bwmap.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwmap/bwmap_ordered.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwparse/bwparse.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/ansi/ansi.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwjson/bwjson.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwparse/bwparse_private.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwtype/bwtype_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwmap/bwmap_ordered_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/ansi/tags/tags.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwval/bwval_def.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwval/bwval_def_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwdebug/bwdebug.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwrune/bwrune.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwerr/where/where.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwerr/bwerr.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwos/bwos_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwparse/bwparse_test.go",
		"/Users/yurybikuzin/go/src/github.com/baza-winner/bwcore/bwval/view@103,_.",
		"/Users/yurybikuzin/Library/Application Support/Sublime Text 3/Packages/GoSublime/CHANGELOG.md",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwtesting/bwtesting.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/def.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/defparse_logic.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/compiledef.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/defvalid_error.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/defvalid_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/defvalid_value.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwerror/bwerror.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/ansi/ansi.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwset/bwset.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/pfa_item_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/defparse_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/pfa.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/pfa_state_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/internal/pfa/pfa_errors.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/defparse.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/internal/pfa/pfa_item_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/internal/pfa/pfa_state_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/internal/pfa/pfa.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/test.sh",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/parsestackitem.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/pfaerrortype_string.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/pfa_errors.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/parsestate.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/parsestackitemtype.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defparse/parsestack.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwint/bwint.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/deftype/deftype.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwmap/bwmap.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwjson/bwjson.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwjson/bwjson_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/defvalid.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/defvalid_init.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/getvalidval.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/deftype.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwmap/bwmap_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/defvalid_errors.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwexec/bwexectesthelper2/bwexectesthelper2.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwtesting/bwtesting_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/ansi/ansi_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwerror/bwerror_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwexec/bwexectesthelper/bwexectesthelper.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwos/bwos.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwstring/bwstring.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwexec/bwexec.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwexec/bwexec_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/bwstring/bwstring_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bwcore/defvalid/value.go",
		"/Users/yurybikuzin/bw/pm/BwAnsi.pm",
		"/Users/yurybikuzin/bw/go/bin/bwexectesthelper",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defvalid/defvalid_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/defparse_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/pfa_state_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/core/core_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/core/core.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defvalid/defvalid.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/pfa.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/pfa_item_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/bwtesting/bwtesting.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/defparse.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parseprimarystate_string.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parsesecondarystate_string.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parsestack.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parsestackitem.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parsestackitemtype.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parsestackitemtype_string.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parsestate.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/parsetertiarystate_string.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparse/pfa_errors.go",
		"/Users/yurybikuzin/bw/go/.gitignore",
		"/Users/yurybikuzin/bw/go/src/.gitignore",
		"/Users/yurybikuzin/bw/go/src/github.com/.gitignore",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/defparser_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/pfa_errors.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/pfa_item_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/pfa_state_methods.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/parsestackitemtype_string.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/ansi/ansi.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/bwcoretestinghelper2/bwcoretestinghelper2.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/bwcoretestinghelper/bwcoretestinghelper.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/ansi/ansi_test.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/parsestackitem.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/pfa.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/parsestate.go",
		"/Users/yurybikuzin/bw/go/src/github.com/baza-winner/bw/defparser/defparser.go",
		"/Users/yurybikuzin/bw/pm/BwProject/v1.pm",
		"/Users/yurybikuzin/bw/core/coreUtils.bash",
		"/Users/yurybikuzin/bw/core/coreFileUtils.bash",
		"/Users/yurybikuzin/bw/pm/BwParams.pm",
		"/Users/yurybikuzin/bw/bash/bwCommands.bash",
		"/Users/yurybikuzin/dip2/bin/dip.pl",
		"/Users/yurybikuzin/dip2/bin/dip.go",
		"/Users/yurybikuzin/.bash_profile",
		"/Users/yurybikuzin/bw/core/funcParamsSupport2.bash",
		"/Users/yurybikuzin/dip2/bin/dip.bash",
		"/Users/yurybikuzin/bw/pm/Bw.pm",
		"/Users/yurybikuzin/bw/pm/BwCore.pm",
		"/Users/yurybikuzin/bw/bash/_docker_up.awk"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 101.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"O",
			"hOpt",
			"TestHolderMustString",
			"a",
			"kindOfInt",
			"[0, 1]",
			"+2.0",
			"-1_000_000",
			"`-1_000_000`",
			"-1",
			"!",
			"+3.14",
			"! ",
			"Delete",
			"TestHolderMustSetKeyVal",
			"1.nonMapKey.some",
			"err: is not Map",
			"keys",
			"values",
			"default [ { some: 273 } ]",
			"parseNumber",
			"Number",
			"default [ { some: 273 } ]",
			"TestHolderMustSetKeyVal",
			"{ val: { some: 0 thing: 1 good: 2 } def: { type Map keys { some Int } } }",
			"MustValidVal",
			"{ val: <some thing> def Array }",
			"err: is not Map",
			"1.nonMapKey.some",
			"KindSwitch",
			"bwdebug.Print",
			"MustSetKeyVal",
			"valueFormat",
			"printCaseToUse",
			"SetKeyVal",
			"KeyVal(",
			"Ordered",
			"KindSwitch",
			"TemplateFrom",
			"ValidateOrderedMapKeyFunc",
			"OnValidateOrderedMapKey",
			"validKeys",
			"KindSwitch",
			"TestValKindString",
			"bwval.PathStr",
			"bwmap",
			"bwos",
			"KeyForPathS",
			"IsL",
			"fromProvider",
			"GetVal",
			"bwparse.From",
			"TemplateFrom",
			"bwjson",
			"GetVal",
			"FromTemplate",
			"bwparse.From(",
			"fmt",
			"Where",
			"\n\t",
			"StringSet",
			"enum",
			"SetTest"
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
			"CmdOpt",
			"opt.h",
			"fromProvider",
			"DelKey",
			"ss",
			"m",
			"// bwdebug.Print",
			"pcToUse",
			"bwval.PathS",
			"keyForPathS",
			"FromProvider",
			"getVal",
			"bwparse.MustFrom(",
			"String",
			"Test"
		],
		"reverse": false,
		"show_context": false,
		"use_buffer2": true,
		"whole_word": true,
		"wrap": false
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "jlf.sublime-syntax",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31239,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"SL.31.region_keys":
							[
							],
							"git_gutter_is_enabled": true,
							"history_list_is_closing": true,
							"markdonw_live_preview_last_run": 1545728623.34,
							"syntax": "Packages/YAML/YAML.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "jlf.sublime-syntax",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 31239,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"SL.32.region_keys":
							[
							],
							"git_gutter_is_enabled": true,
							"history_list_is_closing": true,
							"markdonw_live_preview_last_run": 1545728623.34,
							"syntax": "Packages/YAML/YAML.sublime-syntax",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		},
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 1,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"auto_name": "jjjjjj",
							"git_gutter_is_enabled": false,
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 38.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			],
			[
				2,
				0,
				3,
				1
			]
		],
		"cols":
		[
			0.0,
			0.281098081517,
			0.615858607522,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.GoSublime/HUD":
	{
		"height": 0.0
	},
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 100.0
	},
	"output.mdpopups":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "bwcore.sublime-project",
	"replace":
	{
		"height": 70.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"jlf",
				"jlf.sublime-syntax"
			],
			[
				"bwtesthelp",
				"bwexec/bwexectesthelper2/bwexectesthelper2.go"
			],
			[
				"bwval_hol",
				"bwval/bwval_holder_test.go"
			],
			[
				"bwval_te",
				"bwval/bwval_test.go"
			],
			[
				"bw",
				"bw/bw.go"
			],
			[
				"bwval.",
				"bwval/bwval.go"
			],
			[
				"bwexc",
				"bwexec/bwexec_test.go"
			],
			[
				"bexec",
				"bwexec/bwexec.go"
			],
			[
				"bwos",
				"bwos/bwos.go"
			],
			[
				"bwtype",
				"bwtype/bwtype.go"
			],
			[
				"bwval",
				"bwval/bwval.go"
			],
			[
				"bwparse",
				"bwparse/bwparse_test.go"
			],
			[
				"bwmap",
				"bwmap/bwmap_ordered_test.go"
			],
			[
				"bwtype_te",
				"bwtype/bwtype_test.go"
			],
			[
				"bwval_ho",
				"bwval/bwval_holder_test.go"
			],
			[
				"bwpars",
				"bwparse/bwparse.go"
			],
			[
				"bwval_d",
				"bwval/bwval_def.go"
			],
			[
				"bwval_",
				"bwval/bwval_holder.go"
			],
			[
				"bwdebu",
				"bwdebug/bwdebug.go"
			],
			[
				"bwpar",
				"bwparse/bwparse.go"
			],
			[
				"bwmap_",
				"bwmap/bwmap_ordered.go"
			],
			[
				"bwparse_pr",
				"bwparse/bwparse_private.go"
			],
			[
				"bwval_de",
				"bwval/bwval_def.go"
			],
			[
				"bwexe",
				"bwexec/bwexec_test.go"
			],
			[
				"bwex",
				"bwexec/bwexec.go"
			],
			[
				"bwvla",
				"bwval/bwval.go"
			],
			[
				"bw.",
				"bw/bw.go"
			],
			[
				"w",
				"bwerr/where/where.go"
			],
			[
				"bwjson",
				"bwjson/bwjson.go"
			],
			[
				"bwerr",
				"bwerr/bwerr.go"
			],
			[
				"bwrune",
				"bwrune/bwrune.go"
			],
			[
				"bwexec",
				"bwexec/bwexec_test.go"
			],
			[
				"bwval.go",
				"bwval/bwval.go"
			],
			[
				"bwparse_te",
				"bwparse/bwparse_test.go"
			],
			[
				"ansi",
				"ansi/ansi.go"
			],
			[
				"bwexe_te",
				"bwexec/bwexec_test.go"
			],
			[
				"bwtest",
				"bwtesting/bwtesting.go"
			],
			[
				"def.",
				"defvalid/def.go"
			],
			[
				"bwset",
				"bwset/bwset.go"
			],
			[
				"pfa",
				"pfa/pfa.go"
			],
			[
				"pfa.g",
				"pfa/pfa.go"
			],
			[
				"pfa_a",
				"pfa/pfa_actions.go"
			],
			[
				"pfa_te",
				"pfa/pfa_test.go"
			],
			[
				"rune",
				"runeprovider/runeprovider.go"
			],
			[
				"pfa.",
				"pfa/pfa.go"
			],
			[
				"def",
				"defparse/defparse_logic.go"
			],
			[
				"pfa_",
				"pfa_state_methods.go"
			],
			[
				"defpa",
				"defparse_test.go"
			],
			[
				"pfa_it",
				"pfa_item_methods.go"
			],
			[
				"pfa.go",
				"pfa.go"
			],
			[
				"pfa_er",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_errors.go"
			],
			[
				"pfa_i",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_item_methods.go"
			],
			[
				"pfa_s",
				"go/src/github.com/baza-winner/bwcore/defparse/internal/pfa/pfa_state_methods.go"
			],
			[
				"pfa_e",
				"go/src/github.com/baza-winner/bwcore/defparse/internal/pfa/pfa_errors.go"
			],
			[
				"parsesta",
				"go/src/github.com/baza-winner/bwcore/defparse/parsestackitemtype.go"
			],
			[
				"parsest",
				"go/src/github.com/baza-winner/bwcore/defparse/parsestate.go"
			],
			[
				"parse",
				"go/src/github.com/baza-winner/bwcore/defparse/parsestack.go"
			],
			[
				"pfa_st",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_state_methods.go"
			],
			[
				"test.",
				"go/src/github.com/baza-winner/bwcore/test.sh"
			],
			[
				"defva",
				"go/src/github.com/baza-winner/bwcore/defvalid/defvalid_test.go"
			],
			[
				"stack",
				"go/src/github.com/baza-winner/bwcore/defparse/parsestackitem.go"
			],
			[
				"defpar",
				"go/src/github.com/baza-winner/bwcore/defparse/defparse_test.go"
			],
			[
				"pfa_ite",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_item_methods.go"
			],
			[
				"state",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_state_methods.go"
			],
			[
				"pfa_err",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_errors.go"
			],
			[
				"pfa_item",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_item_methods.go"
			],
			[
				"deftype",
				"go/src/github.com/baza-winner/bwcore/defvalid/deftype/deftype.go"
			],
			[
				"comp",
				"go/src/github.com/baza-winner/bwcore/defvalid/compiledef.go"
			],
			[
				"bwtestg",
				"go/src/github.com/baza-winner/bwcore/bwtesting/bwtesting.go"
			],
			[
				"compile",
				"go/src/github.com/baza-winner/bwcore/defvalid/compiledef.go"
			],
			[
				"defval",
				"go/src/github.com/baza-winner/bwcore/defvalid/defvalid_test.go"
			],
			[
				"defvalid_v",
				"go/src/github.com/baza-winner/bwcore/defvalid/defvalid_value.go"
			],
			[
				"defvali",
				"go/src/github.com/baza-winner/bwcore/defvalid/defvalid.go"
			],
			[
				"defv",
				"go/src/github.com/baza-winner/bwcore/defvalid/defvalid.go"
			],
			[
				"bwtes",
				"go/src/github.com/baza-winner/bwcore/bwtesting/bwtesting.go"
			],
			[
				"getva",
				"go/src/github.com/baza-winner/bwcore/defvalid/getvalidval.go"
			],
			[
				"bwint",
				"go/src/github.com/baza-winner/bwcore/bwint/bwint.go"
			],
			[
				"valid",
				"go/src/github.com/baza-winner/bwcore/defvalid/getvalidval.go"
			],
			[
				"deftyp",
				"go/src/github.com/baza-winner/bwcore/defvalid/deftype/deftype.go"
			],
			[
				"compli",
				"go/src/github.com/baza-winner/bwcore/defvalid/compiledef.go"
			],
			[
				"bwtestin",
				"go/src/github.com/baza-winner/bwcore/bwtesting/bwtesting.go"
			],
			[
				"defvalid_te",
				"go/src/github.com/baza-winner/bwcore/defvalid/defvalid_test.go"
			],
			[
				"pfa_metho",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_item_methods.go"
			],
			[
				"parsestackit",
				"go/src/github.com/baza-winner/bwcore/defparse/parsestackitemtype.go"
			],
			[
				"parseit",
				"go/src/github.com/baza-winner/bwcore/defparse/parsestackitem.go"
			],
			[
				"bwjsonte",
				"go/src/github.com/baza-winner/bwcore/bwjson/bwjson_test.go"
			],
			[
				"bwerror",
				"go/src/github.com/baza-winner/bwcore/bwerror/bwerror.go"
			],
			[
				"bwtesting",
				"go/src/github.com/baza-winner/bwcore/bwtesting/bwtesting.go"
			],
			[
				"bwmapte",
				"go/src/github.com/baza-winner/bwcore/bwmap/bwmap_test.go"
			],
			[
				"pfa_sta",
				"go/src/github.com/baza-winner/bwcore/defparse/pfa_state_methods.go"
			],
			[
				"bwmap_te",
				"go/src/github.com/baza-winner/bwcore/bwmap/bwmap_test.go"
			],
			[
				"bwstr",
				"go/src/github.com/baza-winner/bwcore/bwstring/bwstring.go"
			],
			[
				"ansi.go",
				"go/src/github.com/baza-winner/bwcore/ansi/ansi.go"
			],
			[
				"bwna",
				"pm/BwAnsi.pm"
			],
			[
				"bwstring",
				"go/src/github.com/baza-winner/bwcore/bwstring/bwstring.go"
			],
			[
				"bwmap_t",
				"go/src/github.com/baza-winner/bwcore/bwmap/bwmap_test.go"
			],
			[
				"ansi_",
				"go/src/github.com/baza-winner/bwcore/ansi/ansi_test.go"
			],
			[
				"bwero",
				"go/src/github.com/baza-winner/bwcore/bwerror/bwerror.go"
			],
			[
				"test.sh",
				"go/src/github.com/baza-winner/bwcore/test.sh"
			],
			[
				"bwstrin",
				"go/src/github.com/baza-winner/bwcore/bwstring/bwstring_test.go"
			],
			[
				"defp",
				"go/src/github.com/baza-winner/bwcore/defparse/defparse.go"
			],
			[
				"bwjso",
				"go/src/github.com/baza-winner/bwcore/bwjson/bwjson.go"
			],
			[
				"bwtesit",
				"go/src/github.com/baza-winner/bwcore/bwtesting/bwtesting.go"
			],
			[
				"bwexectes",
				"go/src/github.com/baza-winner/bwcore/bwexec/bwexectesthelper/bwexectesthelper.go"
			],
			[
				"core.",
				"go/src/github.com/baza-winner/bw/core/core.go"
			],
			[
				"core_te",
				"go/src/github.com/baza-winner/bw/core/core_test.go"
			],
			[
				"go/src/github",
				"go/src/github.com/.gitignore"
			],
			[
				"go/src",
				"go/src/.gitignore"
			],
			[
				"go/.gi",
				"go/.gitignore"
			],
			[
				"core_tes",
				"go/src/github.com/baza-winner/bw/core/core_test.go"
			],
			[
				"ansi_te",
				"go/src/github.com/baza-winner/bw/ansi/ansi_test.go"
			],
			[
				"pfa_state_",
				"go/src/github.com/baza-winner/bw/defparser/pfa_state_methods.go"
			],
			[
				"parsestackitemtype_string.go",
				"go/src/github.com/baza-winner/bw/defparser/parsestackitemtype_string.go"
			],
			[
				".git",
				"go/.gitignore"
			],
			[
				"bwcore",
				"go/src/github.com/baza-winner/bw/bwcoretestinghelper/bwcoretestinghelper.go"
			],
			[
				"bwCore",
				"go/src/github.com/baza-winner/bw/bwcoretesting/bwcoretesting.go"
			],
			[
				"docker_up",
				"bash/_docker_up.awk"
			],
			[
				"coreFile",
				"core/coreFileUtils.bash"
			],
			[
				"bwCom",
				"bash/bwCommands.bash"
			],
			[
				"BwAn",
				"pm/BwAnsi.pm"
			],
			[
				"coreFil",
				"core/coreFileUtils.bash"
			],
			[
				"Bw",
				"pm/Bw.pm"
			],
			[
				"bwCo",
				"bash/bwCommands.bash"
			],
			[
				"core",
				"core/coreUtils.bash"
			],
			[
				"BwCor",
				"pm/BwCore.pm"
			],
			[
				"func",
				"core/funcParamsSupport2.bash"
			],
			[
				"BwP",
				"pm/BwParams.pm"
			],
			[
				"bwP",
				"pm/BwParams.pm"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 2,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": true,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 83.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}

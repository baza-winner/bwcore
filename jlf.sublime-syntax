%YAML 1.2
---
name: JLF
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions: [ jlf ]
scope: source.jlf

variables:
  space: '[\s]+'
  beginOfSingleLineComment: '//'
  beginOfMultiLineComment: '/\*'
  endOfMultiLineComment: '\*/'

  any: '(?=.)'

  number: '[\+\-]?\d+(?:\.\d+)?'
  id: '[a-zA-Z_]([a-zA-Z_\d\.-]*)'
  bool: true|false
  nil: nil

  keySeparator: '(\s[=-]>|\s=|:)?(\s|$)'
  commaSeparatorOptional: ','

  beginOfMap: '\{'
  endOfMap: '\}'

  beginOfArray: '\['
  endOfArray: '\]'

  beginOfVarDefBlock: '\('
  endOfVarDefBlock: '\)'
  beginOfExpr: '\('
  endOfExpr: '\)'

  beginOfArgs: '\{'
  endOfArgs: '\}'

  beginOfIterator: '\['
  endOfIterator: '\]'

  doubleQuotedStringDelimiter: '"'

  escapeStarter: '\\'
  varSpecStarter: '\$'
  varDefStarter: '\$'
  fileSpecStarter: '%'
  defStarter: '\^'
  genStarter: '\&'
  pathSpecStarter: '\*'
  exprPathStarter: '[{{fileSpecStarter}}{{varSpecStarter}}{{pathSpecStarter}}]'
  pathSegmentSpecStarter: '[^^\s\(\|\*%]'

  int: '[-+]?\d+'

  pathSegmentSeparator: '\|(?!\|)'
  rangeSeparator: '\.\.'
  negationMark: '!'

  ternaryIf: '\?'
  ternaryDelimiter: ':'

  spaceAfter: '(\s|$)'
  sumOps: '[\+\-]'
  mulOps: '[\*\/]'
  andOp: '(\&\&)'
  orOp: '(\|\|)'
  cmpOps: '(==|!=|<=|>=)'

  defTypeSingle: 'Array|Map|String|Int|Number|Bool|Range|Def|Gen|Any|AnyBut'
  defTypeMulti: 'ArrayOf'

  pathUpperLevel: '\.\.(?={{endOfNonQuotedString}})'
  pathCurrLevel: '(?!{{pathUpperLevel}})\.(?={{endOfNonQuotedString}})'
  optionalEnder: '\?'
  pathDefaultValueStarter: ':'
  beginOfNonQuotedKey: '(?=[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparatorOptional}}])(?!{{endOfNonQuotedKey}})'
  endOfNonQuotedKey: '{{space}}|{{optionalEnder}}|{{beginOfExpr}}|{{endOfExpr}}|{{beginOfMap}}|{{beginOfArray}}|{{keySeparator}}'
  beginOfNonQuotedString: '(?=[\\a-zA-Z_\.])'
  endOfNonQuotedString: '{{space}}|{{optionalEnder}}|{{beginOfExpr}}|{{endOfExpr}}|{{pathSegmentSeparator}}|{{beginOfMap}}|{{beginOfArray}}|{{endOfMap}}|{{endOfArray}}|{{commaSeparatorOptional}}|{{defStarter}}'
  jsonQuotedEscapeRunes: '[bfnrt]'
  jsonQuotedEscapeRunesAsIs: '["\\/]'
  escapeRunes: '[abfnrtv]'
  nonQuotedKeyBegin: '[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparatorOptional}}]'
  doubleQuotedValidRune: '\x{0020}-\x{10ffff}'

# =============================================================================
# =============================================================================

contexts:

  prototype:
    - include: spaceInclude

  spaceInclude:
    - meta_include_prototype: false
    - match: '{{space}}'
    - match: '{{beginOfSingleLineComment}}'
      scope: punctuation.definition.comment.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment.line.jlf
        - match: $
          pop: true
    - match: '{{beginOfMultiLineComment}}'
      scope: punctuation.definition.comment.begin.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment
        - match: '{{endOfMultiLineComment}}'
          scope: punctuation.definition.comment.end.jlf
          pop: true

  illegalInclude:
    - meta_include_prototype: false
    - match: .
      scope: invalid.illegal.jlf

# =============================================================================

  varDefInclude:
    - match: '({{varDefStarter}}){{beginOfVarDefBlock}}'
      captures:
        1: keyword.jlf
      push:
        - match: '{{endOfVarDefBlock}}'
          pop: true
        - match: '{{defStarter}}'
          scope: variable.parameter.jlf
          push: [defValue, keySeparatorOptional]
        - match: '{{id}}'
          scope: entity.name.jlf
          push: [value, keySeparatorOptional, varDefArgsOptional]
        - include: illegalInclude
    - match: '({{varDefStarter}})({{defStarter}})'
      captures:
        1: keyword.jlf
        2: variable.parameter.jlf
      push: [defValue, keySeparatorOptional]
    - match: '({{varDefStarter}})({{id}})'
      captures:
        1: keyword.jlf
        2: entity.name.jlf
      push: [value, keySeparatorOptional, varDefArgsOptional]

  main:
    - match: '{{any}}'
      set: [mainTail, mainArgsOptional]

  mainArgsOptional:
    - match: '({{varDefStarter}})(?={{beginOfArgs}})'
      scope: keyword.jlf
      set: varDefArgsOptional
    - match: '{{any}}'
      pop: true

  mainTail:
    - match: '({{varDefStarter}}){{beginOfVarDefBlock}}'
    - include: varDefInclude
    - match: '{{any}}'
      set: [end, value]

  end:
    - include: varDefInclude
    - include: illegalInclude

# =============================================================================

  varDefArgsOptional:
    - meta_include_prototype: false
    - match: '{{beginOfArgs}}'
      scope: punctuation.section.parens.begin.jlf
      set:
      - match: '{{endOfArgs}}'
        scope: punctuation.section.block.end.jlf
        pop: true
      - match: '{{any}}'
        push: [ defValue, keySeparatorOptional, optionalEnderOptional, argName]
    - match: '{{any}}'
      pop: true

  argName:
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: entity.name.variable.jlf
        - include: quotedInclude
    - match: '{{beginOfNonQuotedKey}}'
      set:
        - meta_include_prototype: false
        - meta_scope: entity.name.variable.jlf
        - match: '(?={{endOfNonQuotedKey}})'
          pop: true
        - match: '(\\){{endOfNonQuotedKey}}'
          captures:
            1: constant.character.escape.jlf
        - include: escapeInclude
    - include: illegalInclude

# =============================================================================

  genValue:
    - include: commonValueInclude
    - match: '{{any}}'
      set: [gen, genStarterOptional]

  genStarterOptional:
    - match: '{{genStarter}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  genInclude:
    - meta_include_prototype: false
    - match: '{{genStarter}}'
      scope: keyword.jlf
      set: gen

  gen:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: entity.name.jlf
      set: keyOfGen
    - include: illegalInclude

  keyOfGen:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, genType, keySeparatorOptional]
    - match: \bkey|value\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, value, keySeparatorOptional]
    - match: \belem\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, gen, keySeparatorOptional]
    - include: illegalInclude

  genType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true

# =============================================================================

  iteratorNegationOptional:
    - meta_include_prototype: false
    - match: '{{negationMark}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  iteratorConditionOptional:
    - match: '{{int}}'
      scope: constant.numeric.jlf
      set: rangeOptinal
    - match: '{{beginOfExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set: [rangeOptinal, exprEnd, expr]
    - include: stringInclude
    - match: '{{any}}'
      pop: true

  iteratorEnd:
    - meta_include_prototype: false
    - match: '{{endOfIterator}}'
      scope: punctuation.section.bracket.begin.jlf
      set:
        - meta_include_prototype: false
        - match: '{{beginOfIterator}}'
          scope: punctuation.section.bracket.begin.jlf
          set: [iteratorEnd, iteratorConditionOptional, iteratorNegationOptional]
        - match: '{{any}}'
          set: genValue
    - include: illegalInclude

# =============================================================================

  pathInclude:
    - meta_include_prototype: false
    - match: '(?={{exprPathStarter}})'
      set: [pathNextSegmentOptional, pathStartSegment]

  pathNextSegmentOptional:
    - match: '{{pathSegmentSeparator}}'
      scope: keyword.jlf
      push: pathSegmentSpec
    - match: '{{any}}'
      pop: true

  pathStartSegment:
    - meta_include_prototype: false
    - match: '([{{fileSpecStarter}}{{varSpecStarter}}])({{beginOfArgs}})'
      captures:
        1: keyword.jlf
        2: invalid.illegal.jlf
    - include: varSpecInclude
    - match: '{{fileSpecStarter}}'
      scope: keyword.jlf
      set:
        - meta_include_prototype: false
        - match: '(?={{endOfNonQuotedString}})'
          set: illegalInclude
        - match: '{{any}}'
          set:
            - meta_include_prototype: false
            - clear_scopes: true
            - meta_scope: entity.name.label.jlf
            - include: specInclude
    - match: '{{pathSpecStarter}}'
      scope: keyword.jlf
      set:
        - clear_scopes: true
        - meta_scope: entity.name.label.jlf
        - match: '{{pathCurrLevel}}'
          pop: true
        - match: '({{pathUpperLevel}})(?:\s*({{pathSegmentSeparator}})\s*({{pathUpperLevel}}))*'
          captures:
            2: keyword.jlf
          pop: true
        - match: '{{any}}'
          set: pathSegmentSpec

  pathSegmentSpec:
    - match: '(?={{defStarter}})'
      set: [pathNextSegmentOptional, defWithStarter]
    - match: '{{beginOfIterator}}'
      scope: punctuation.section.bracket.begin.jlf
      set: [pathNextSegmentOptional, iteratorEnd, iteratorConditionOptional, iteratorNegationOptional]
    - include: intInclude
    - include: intSubExprInclude
    - include: varSpecInclude
    - include: pathSegmentSpecHelperInclude
    - include: simplePathSegmentSpecInclude
    - include: illegalInclude

  pathSegmentSpecHelperInclude:
    - meta_include_prototype: false
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - include: quotedInclude
    - match: '{{pathSegmentSpecStarter}}'
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}(?={{beginOfExpr}})'
          scope: keyword.jlf
          push: expr
        - match: '(?={{endOfNonQuotedString}})'
          pop: true
        - match: '({{escapeStarter}}){{endOfNonQuotedString}}'
          captures:
            1: constant.character.escape.jlf
        - include: escapeInclude

  varSpecInclude:
    - meta_include_prototype: false
    - match: '{{varSpecStarter}}'
      scope: keyword.jlf
      set:
        - meta_include_prototype: false
        - match: '(?={{endOfNonQuotedString}})'
          set: illegalInclude
        - match: '{{any}}'
          set:
            - meta_include_prototype: false
            - clear_scopes: true
            - meta_scope: entity.name.variable.jlf
            - include: specInclude

  specInclude:
    - meta_include_prototype: false
    - match: '(?={{beginOfArgs}})'
      set:
        - match: '{{beginOfArgs}}'
          scope: punctuation.section.block.begin.jlf
          set:
            - match: '{{endOfArgs}}'
              scope: punctuation.section.block.end.jlf
              pop: true
            - match: '{{any}}'
              push: [ commaSeparatorOptional, value, keySeparatorOptional, argName ]
    - match: '(?={{beginOfMap}})'
      set:
        - meta_include_prototype: false
        - clear_scopes: true
        - include: mapInclude
    - include: nonQuotedStringTailInclude

# =============================================================================

  exprInclude:
    - meta_include_prototype: false
    - match: '{{beginOfExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set:
        - match: '{{negationMark}}'
          set: [exprEnd, exprTernaryBeginOptional, boolExprTailOptional, valueAtom]
        - match: '{{any}}'
          set: [exprEnd, exprTernaryBeginOptional, exprTailOptional, valueAtom]

  negationMarkOptional:
    - meta_include_prototype: false
    - match: '{{negationMark}}'
      pop: true
    - match: '{{any}}'
      pop: true

  exprEnd:
    - match: '{{endOfExpr}}'
      scope: punctuation.section.parens.end.jlf
      pop: true
    - include: illegalInclude

  expr:
    - include: exprInclude
    - include: illegalInclude

  exprSumTailInclude:
    - match: '{{sumOps}}{{spaceAfter}}'
      set: [ exprSumTailOptional, valueAtom ]

  exprSumTailOptional:
    - include: exprSumTailInclude
    - match: '{{any}}'
      pop: true

  exprMulTailInclude:
    - match: '{{mulOps}}{{spaceAfter}}'
      set: [ exprMulTailOptional, valueAtom ]

  exprMulTailOptional:
    - include: exprMulTailInclude
    - match: '{{any}}'
      pop: true

  exprOrTailInclude:
    - match: '{{orOp}}{{spaceAfter}}'
      set: [ exprOrTailOptional, valueAtom, negationMarkOptional]

  exprOrTailOptional:
    - include: exprOrTailInclude
    - match: '{{any}}'
      pop: true

  exprAndTailInclude:
    - match: '{{andOp}}{{spaceAfter}}'
      set: [ exprAndTailOptional, valueAtom, negationMarkOptional]

  exprAndTailOptional:
    - include: exprAndTailInclude
    - match: '{{any}}'
      pop: true

  boolExprTailInclude:
    - include: exprOrTailInclude
    - include: exprAndTailInclude

  boolExprTailOptional:
    - include: boolExprTailInclude
    - match: '{{any}}'
      pop: true

  exprTailOptional:
    - include: exprSumTailInclude
    - include: exprMulTailInclude
    - match: '{{cmpOps}}{{spaceAfter}}'
      scope: keyword.operator.logical.jlf
      set: [valueAtom]
    - include: boolExprTailInclude
    - match: '{{any}}'
      pop: true

  exprTernaryBeginOptional:
    - match: '{{ternaryIf}}{{ternaryDelimiter}}'
      scope: keyword.jlf
      push: valueWithoutTernary
    - match: '{{ternaryIf}}'
      scope: keyword.jlf
      push: [valueWithoutTernary, exprTernaryDelimiter, valueWithoutTernary]
    - match: '{{any}}'
      pop: true

  exprTernaryIf:
    - match: '{{ternaryIf}}'
      scope: keyword.jlf
      pop: true
    - include: illegalInclude

  exprTernaryDelimiter:
    - match: '{{ternaryDelimiter}}'
      pop: true
    - include: illegalInclude

# =============================================================================

  intInclude:
    - match: '{{int}}'
      scope: constant.numeric.jlf
      pop: true

# =============================================================================

  escapeInclude:
    - meta_include_prototype: false
    - match: '(?=\\$)'
      set:
        - include: illegalInclude
    - match: '\\{{escapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '\\"'
      scope: constant.character.escape.jlf
      push:
        - match: '"'
          scope: constant.character.escape.jlf
          pop: true
    - match: '(\\).'
      captures:
        1: comment.jlf

  nonQuotedStringTailInclude:
    - meta_include_prototype: false
    - match: '{{escapeStarter}}(?={{beginOfExpr}})'
      scope: keyword.jlf
      push: expr
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '({{escapeStarter}}){{endOfNonQuotedString}}'
      captures:
        1: constant.character.escape.jlf
    - include: escapeInclude

  quotedInclude:
    - meta_include_prototype: false
    - match: '{{escapeStarter}}u'
      push:
        - meta_scope: constant.character.escape.jlf
        - match: '[0-9a-fA-F]{4}'
          pop: true
        - include: illegalInclude
    - match: '{{escapeStarter}}{{jsonQuotedEscapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '({{escapeStarter}})({{jsonQuotedEscapeRunesAsIs}})'
      captures:
        1: constant.character.escape.jlf
    - match: '({{escapeStarter}})([{{doubleQuotedValidRune}}])'
      captures:
        1: comment.jlf
    - match: '(?={{escapeStarter}}|[^{{doubleQuotedValidRune}}])'
      set:
        - include: illegalInclude
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.end.jlf
      pop: true

  quotedStringInclude:
    - meta_include_prototype: false
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.jlf
        - match: '{{escapeStarter}}(?={{beginOfExpr}})'
          scope: keyword.jlf
          push: expr
        - include: quotedInclude

# =============================================================================

  valueStart:
    - match: '(?={{exprPathStarter}})'
      set: pathStartSegment
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: rangeOptinal
    - match: '(?={{beginOfExpr}})'
      set: [rangeOptinal, expr]
    - include: mapInclude
    - include: defInclude
    - include: genInclude
    - include: arrayInclude
    - include: boolInclude
    - include: nilInclude
    - include: stringInclude
    - include: illegalInclude

  valueAtom:
    - match: '{{any}}'
      set: [pathNextSegmentOptional, valueStart]

  valueWithoutTernary:
    - match: '{{negationMark}}'
      set: [boolExprTailOptional, valueAtom]
    - match: '{{any}}'
      set: [exprTailOptional, valueAtom]

  value:
    - match: '{{any}}'
      set: [exprTernaryBeginOptional, valueWithoutTernary]

  rangeOptinal:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      set: numberValue
    - match: '{{any}}'
      pop: true

# =====================================

  stringInclude:
    - meta_include_prototype: false
    - include: quotedStringInclude
    - match: '{{beginOfNonQuotedString}}'
      set:
        - meta_include_prototype: false
        - meta_scope: string.jlf
        - include: nonQuotedStringTailInclude

# =====================================

  mapInclude:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfMap}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [ commaSeparatorOptional, value, keySeparatorOptional, optionalEnderOptional, key ]

  key:
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - include: quotedInclude
    - match: '{{beginOfNonQuotedKey}}'
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '(?={{endOfNonQuotedKey}})'
          pop: true
        - match: '(\\){{endOfNonQuotedKey}}'
          captures:
            1: constant.character.escape.jlf
        - include: escapeInclude
    - include: illegalInclude

  keySeparatorOptional:
    - meta_include_prototype: false
    - match: '{{keySeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  commaSeparatorOptional:
    - match: '{{commaSeparatorOptional}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =====================================

  arrayInclude:
    - meta_include_prototype: false
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfArray}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [commaSeparatorOptional, value]

# =====================================

  boolInclude:
    - meta_include_prototype: false
    - match: \b{{bool}}\b
      scope: constant.language.jlf
      pop: true

# =====================================

  nilInclude:
    - meta_include_prototype: false
    - match: \b{{nil}}\b
      scope: constant.language.jlf
      pop: true

# =============================================================================

  rangeValue:
    - include: pathInclude
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: [ numberValue, rangeSeparator ]
    - match: '(?={{beginOfExpr}})'
      set: [rangeOptinal, expr]
    - include: illegalInclude

  rangeSeparator:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      pop: true
    - include: illegalInclude

  numberValue:
    - include: numberInclude
    - include: exprInclude
    - include: illegalInclude

  numberInclude:
    - match: '{{number}}'
      scope: constant.numeric.jlf
      pop: true

# =============================================================================

  commonValueInclude:
    - meta_include_prototype: false
    - include: pathInclude
    - include: exprInclude

# =============================================================================

  stringsValue:
    - include: commonValueInclude
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set: [stringsExprTailOptional, stringsValueArrayTail]
    - include: stringInclude
    - include: illegalInclude

  stringsValueArrayTail:
    - match: '{{endOfArray}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      push: [ commaSeparatorOptional, stringsValue ]

  stringsExprTailOptional:
    - match: '(\+|\-)\s'
      scope: keyword.operator.arithmetic.jlf
      push: [stringsExprTailOptional, stringsValue]
    - match: '{{any}}'
      pop: true

# =============================================================================

  defValue:
    - include: commonValueInclude
    - match: '{{any}}'
      set: [def, defStarterOptional]

  defStarterOptional:
    - match: '{{defStarter}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  defInclude:
    - meta_include_prototype: false
    - match: '{{defStarter}}'
      scope: keyword.jlf
      set: def

  defWithStarter:
    - match: '(?={{defStarter}})'
      set:
        - include: defInclude
    - include: illegalInclude

  def:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: keyOfDef
    - match: '{{any}}'
      set: defType

  keyOfDef:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, defType, keySeparatorOptional]
    - match: \bkeysDef\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, defKeysDefValue, keySeparatorOptional]
    - match: \b(enum|keys)\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, stringsValue, keySeparatorOptional]
    - match: \b(elemDef|arrayElemDef)\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, defValue, keySeparatorOptional]
    - match: \brange\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, rangeValue, keySeparatorOptional]
    - match: \bisOptional\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, boolValue, keySeparatorOptional]
    - match: \bdefault\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, value, keySeparatorOptional]
    - include: illegalInclude

  defType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfArray}}'
          pop: true
        - match: \b{{defTypeMulti}}|{{defTypeSingle}}\b
          scope: variable.parameter
        - include: illegalInclude
    - include: illegalInclude

# =============================================================================

  defKeysDefValueInclude:
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfMap}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [ defValue, keySeparatorOptional, optionalEnderOptional, key]

  defKeysDefValue:
    - include: commonValueInclude
    - include: defKeysDefValueInclude
    - include: illegalInclude

# =============================================================================

  optionalEnderOptional:
    - meta_include_prototype: false
    - match: '{{optionalEnder}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =============================================================================

  boolValue:
    - include: commonValueInclude
    - include: boolInclude
    - include: illegalInclude

# =============================================================================

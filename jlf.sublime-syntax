%YAML 1.2
---
name: JLF
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions: [ jlf ]
scope: source.jlf

variables:
  space: '[\s]+'
  beginOfSingleLineComment: '//'
  beginOfMultiLineComment: '/\*'
  endOfMultiLineComment: '\*/'

  any: '(?=.)'

  number: '[\+\-]?\d+(?:\.\d+)?'
  id: '[a-zA-Z_]([a-zA-Z_\d\.-]*)'
  bool: true|false
  nil: nil

  keySeparator: '(=>|:?=|:)'
  commaSeparator: ','

  beginOfMap: '\{'
  endOfMap: '\}'

  beginOfArray: '\['
  endOfArray: '\]'

  beginOfVarDefBlock: '\('
  endOfVarDefBlock: '\)'
  beginOfExpr: '\('
  endOfExpr: '\)'

  beginOfArgs: '\('
  endOfArgs: '\)'

  doubleQuotedStringDelimiter: '"'

  escapeStarter: '\\'
  varSpecStarter: '\$'
  varDefStarter: '!'
  fileSpecStarter: '%'
  defStarter: '\^'
  pathSpecStarter: '\*'
  exprPathStarter: '[{{fileSpecStarter}}{{varSpecStarter}}{{pathSpecStarter}}]'
  pathSegmentSpecStarter: '[^^\s\(\|\*%]'

  int: '[-+]?\d+'

  pathSegmentSeparator: '\|'
  rangeSeparator: '\.\.'

  defTypeSingle: 'Array|Map|String|Int|Number|Bool|Range|Def'
  defTypeMulti: 'ArrayOf'

  pathUpperLevel: '\.\.(?={{endOfNonQuotedString}})'
  pathCurrLevel: '(?!{{pathUpperLevel}})\.(?={{endOfNonQuotedString}})'
  pathOptionalSign: '\?'
  pathDefaultValueStarter: ':'
  beginOfNonQuotedKey: '(?=[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparator}}])(?!{{endOfNonQuotedKey}})'
  endOfNonQuotedKey: '{{space}}|{{pathOptionalSign}}|{{beginOfExpr}}|{{endOfExpr}}|{{beginOfMap}}|{{beginOfArray}}|{{keySeparator}}'
  beginOfNonQuotedString: '(?=[\\a-zA-Z_\.])'
  endOfNonQuotedString: '{{space}}|{{pathOptionalSign}}|{{beginOfExpr}}|{{endOfExpr}}|{{pathSegmentSeparator}}|{{beginOfMap}}|{{beginOfArray}}|{{endOfMap}}|{{endOfArray}}|{{commaSeparator}}|{{defStarter}}'
  jsonQuotedEscapeRunes: '[bfnrt]'
  jsonQuotedEscapeRunesAsIs: '["\\/]'
  escapeRunes: '[abfnrtv]'
  nonQuotedKeyBegin: '[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparator}}]'
  doubleQuotedValidRune: '\x{0020}-\x{10ffff}'

# =============================================================================
# =============================================================================

contexts:

  prototype:
    - include: spaceInclude

  spaceInclude:
    - meta_include_prototype: false
    - match: '{{space}}'
    - match: '{{beginOfSingleLineComment}}'
      scope: punctuation.definition.comment.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment.line.jlf
        - match: $
          pop: true
    - match: '{{beginOfMultiLineComment}}'
      scope: punctuation.definition.comment.begin.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment
        - match: '{{endOfMultiLineComment}}'
          scope: punctuation.definition.comment.end.jlf
          pop: true

  illegalInclude:
    - meta_include_prototype: false
    - match: .
      scope: invalid.illegal.jlf

# =============================================================================

  varDefInclude:
    - match: '({{varDefStarter}}){{beginOfVarDefBlock}}'
      captures:
        1: keyword.jlf
      push:
        - match: '{{endOfVarDefBlock}}'
          pop: true
        - match: '{{defStarter}}'
          scope: variable.parameter.jlf
          push: [defValue, keySeparator]
        - match: '{{id}}'
          scope: entity.name.jlf
          push: [value, keySeparator, varDefArgs]
        - include: illegalInclude
    - match: '({{varDefStarter}})({{defStarter}})'
      captures:
        1: keyword.jlf
        2: variable.parameter.jlf
      push: [defValue, keySeparator]
    - match: '({{varDefStarter}})({{id}})'
      captures:
        1: keyword.jlf
        2: entity.name.jlf
      push: [value, keySeparator, varDefArgs]

  main:
    - include: varDefInclude
    - match: '{{any}}'
      set: [end, value]

  end:
    - include: varDefInclude
    - include: illegalInclude

# =============================================================================

  # defExpr:
  #   - match: '{{any}}'
  #     set: [defExprTail, defValue]

  defValue:
    # - match: '{{beginOfExpr}}'
    #   scope: punctuation.section.parens.begin.jlf
    #   set: [exprEnd, defExpr]
    # - include: pathInclude
    - include: simplePathInclude
    - include: exprInclude
    - match: '{{any}}'
      set: [defBegin, defStarter]

  defStarter:
    - match: '{{defStarter}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  # defExprTail:
  #   - match: '(\+)\s'
  #     scope: keyword.operator.arithmetic.jlf
  #     push: defValue
  #   - match: '{{any}}'
  #     pop: true

# =============================================================================

  varDefArgs:
    - meta_include_prototype: false
    - match: '{{beginOfArgs}}'
      set:
        - match: '({{varDefStarter}})?({{id}})'
          captures:
            1: comment.jlf
            2: entity.name.jlf
          push: commaSeparator
        - match: '{{endOfArgs}}'
          pop: true
    - match: '{{any}}'
      pop: true

# =============================================================================

  # specInclude:
  #   - meta_include_prototype: false
  #   - match: '(?={{beginOfArgs}})'
  #     set:
  #       - meta_include_prototype: false
  #       - match: '{{beginOfArgs}}'
  #         scope: punctuation.section.parens.begin.jlf
  #         set:
  #           - meta_include_prototype: false
  #           - match: '{{endOfArgs}}'
  #             pop: true
  #           - match: '{{any}}'
  #             push: [commaSeparator, value]
  #       - include: illegalInclude
  #   - include: nonQuotedStringTailInclude

# =============================================================================

  simplePathInclude:
    - meta_include_prototype: false
    - match: '(?={{exprPathStarter}})'
      set: [pathStartSegment]

  # simplePathNextSegment:
  #   - match: '{{pathSegmentSeparator}}'
  #     scope: keyword.jlf
  #     push: pathSegmentSpec
  #   - match: '{{any}}'
  #     pop: true

  # exprPath:
  #   - meta_include_prototype: false
  #   - match: '{{beginOfExpr}}'
  #     set: [exprEnd, path]
  #   - include: illegalInclude
    # (?# - match: '(?={{exprPathStarter}})')
      # set: [pathTail, pathStartSegment]


  # path:
  #   - include: pathInclude
  #   - include: illegalInclude

  # pathInclude:
  #   - meta_include_prototype: false
  #   - match: '(?={{exprPathStarter}})'
  #     set: [pathTail, pathStartSegment]

  # pathExprInclude:
  #   - meta_include_prototype: false
  #   - match: '(?={{exprPathStarter}})'
  #     set: [exprEnd, pathTail, pathStartSegment]

  # pathTail:
  #   - meta_include_prototype: false
  #   - match: '{{any}}'
  #     set: [pathNextSegment, pathOptional, pathTailDefOrGen]
      # set: [pathOptional, pathTailDefOrGen]

  # pathTailOfStillSimplePath:
  #   - meta_include_prototype: false
  #   - match: '{{defStarter}}'
  #     scope: keyword.jlf
  #     set: [pathNextSegment, pathOptional, defBegin]
  #   - match: '\['
  #     scope: keyword.jlf
  #     set: [pathNextSegment, pathOptional, pathTailIteratorEnd, pathTailIteratorCondition, pathTailIteratorNegation]
  #   - match: '{{pathOptionalSign}}'
  #     scope: keyword.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - match: '{{pathDefaultValueStarter}}'
  #         scope: keyword.jlf
  #         set: [pathNextSegment, value]
  #       - match: '{{any}}'
  #         set: pathNextSegment
  #   - match: '{{pathSegmentSeparator}}'
  #     scope: keyword.jlf
  #     push: pathSegmentSpec
  #   - match: '{{any}}'
  #     pop: true
  #     # set: [pathNextSegment, pathOptional, pathTailDefOrGen]
  #     # set: [pathOptional, pathTailDefOrGen]

  # pathTailDefOrGen:
  #   - meta_include_prototype: false
  #   - match: '{{defStarter}}'
  #     scope: keyword.jlf
  #     set: defBegin
  #   - match: '\['
  #     scope: punctuation.section.bracket.begin.jlf
  #     # scope: keyword.jlf
  #     set: [pathTailIteratorEnd, pathTailIteratorCondition, pathTailIteratorNegation]
  #   - match: '{{any}}'
  #     pop: true

  genBegin:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      push: [commaSeparator, genType, keySeparator]
    - match: \bkey|value\b
      scope: keyword.jlf
      push: [commaSeparator, value, keySeparator]
    - match: \belem\b
      scope: keyword.jlf
      push: [commaSeparator, gen, keySeparator]
    - include: illegalInclude

  genInclude:
    - meta_include_prototype: false
    - match: '\{'
      scope: entity.name.jlf
      set: genBegin

  gen:
    - include: genInclude
    - include: illegalInclude

  genType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true

  pathTailIteratorNegation:
    - meta_include_prototype: false
    - match: '!'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  pathTailIteratorCondition:
    - match: '{{int}}'
      scope: constant.numeric.jlf
      set: mayBeRange
    - match: '{{beginOfExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set: [mayBeRange, exprEnd, expr]
    - include: stringInclude
    - match: '{{any}}'
      pop: true

  pathTailIteratorEnd:
    - meta_include_prototype: false
    - match: '\]'
      scope: punctuation.section.bracket.begin.jlf
      # scope: entity.name.jlf
      set:
        - meta_include_prototype: false
        - match: '\['
          scope: punctuation.section.bracket.begin.jlf
          # scope: keyword.jlf
          set: [pathTailIteratorEnd, pathTailIteratorCondition, pathTailIteratorNegation]
        - match: '\{'
          scope: entity.name.jlf
          set: genBegin
    - include: illegalInclude

  pathOptional:
    - match: '{{pathOptionalSign}}'
      scope: keyword.jlf
      push:
        - meta_include_prototype: false
        - match: '{{pathDefaultValueStarter}}'
          scope: keyword.jlf
          set: value
        - match: '{{any}}'
          pop: true
    - match: '{{any}}'
      pop: true

  pathNextSegmentOfStillSimplePath:
    - match: '{{pathSegmentSeparator}}'
      scope: keyword.jlf
      set: [pathTailOfStillSimplePath, pathSegmentSpec]
    - match: '{{any}}'
      pop: true

  pathNextSegment:
    - match: '{{pathSegmentSeparator}}'
      scope: keyword.jlf
      push: pathSegmentSpec
      # set: [pathTail, pathSegmentSpec]
    - match: '{{any}}'
      pop: true

  pathTailInclude:
    - match: '{{pathSegmentSeparator}}'
      scope: keyword.jlf
      push: pathSegmentSpec
    - match: '{{any}}'
      pop: true

  pathStartSegment:
    - meta_include_prototype: false
    - match: '([{{fileSpecStarter}}{{varSpecStarter}}])({{beginOfArgs}})'
      captures:
        1: keyword.jlf
        2: invalid.illegal.jlf
    - include: varSpecInclude
    - match: '{{fileSpecStarter}}'
      scope: keyword.jlf
      set:
        - meta_include_prototype: false
        - match: '(?={{endOfNonQuotedString}})'
          set: illegalInclude
        - match: '{{any}}'
          set:
            - meta_include_prototype: false
            - clear_scopes: true
            - meta_scope: entity.name.label.jlf
            - include: nonQuotedStringTailInclude
            # - include: specInclude
    - match: '{{pathSpecStarter}}'
      scope: keyword.jlf
      set:
        - clear_scopes: true
        - meta_scope: entity.name.label.jlf
        - match: '{{pathCurrLevel}}'
          pop: true
        - match: '({{pathUpperLevel}})(?:\s*({{pathSegmentSeparator}})\s*({{pathUpperLevel}}))*'
          captures:
            2: keyword.jlf
          pop: true
        - match: '{{any}}'
          set: pathSegmentSpec

  pathSegmentSpec:
    - meta_include_prototype: false
    - include: intInclude
    - include: intSubExprInclude
    - include: varSpecInclude
    - include: pathSegmentSpecHelperInclude
    - include: illegalInclude

  pathSegmentSpecHelperInclude:
    - meta_include_prototype: false
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - include: quotedInclude
    - match: '{{pathSegmentSpecStarter}}'
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}(?={{beginOfExpr}})'
          scope: keyword.jlf
          push: expr
        - match: '(?={{endOfNonQuotedString}})'
          pop: true
        - match: '({{escapeStarter}}){{endOfNonQuotedString}}'
          captures:
            1: constant.character.escape.jlf
        - include: escapeInclude

  varSpecInclude:
    - meta_include_prototype: false
    - match: '{{varSpecStarter}}'
      scope: keyword.jlf
      set:
        - meta_include_prototype: false
        - match: '(?={{endOfNonQuotedString}})'
          set: illegalInclude
        - match: '{{any}}'
          set:
            - meta_include_prototype: false
            - clear_scopes: true
            - meta_scope: entity.name.variable.jlf
            - match: '(?={{beginOfArgs}})'
              set:
                - meta_include_prototype: false
                - match: '{{beginOfArgs}}'
                  scope: punctuation.section.parens.begin.jlf
                  set:
                    - meta_include_prototype: false
                    - match: '{{endOfArgs}}'
                      scope: punctuation.section.parens.end.jlf
                      pop: true
                    - match: '{{any}}'
                      push: [commaSeparator, value]
                - include: illegalInclude
            - include: nonQuotedStringTailInclude

# =============================================================================

  exprInclude:
    - meta_include_prototype: false
    - match: '{{beginOfExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set:
        # - include: pathExprInclude
        - match: '{{any}}'
          set: [exprEnd, exprTernaryMayBegin, exprTail, value]
      # set: [exprEnd, exprContent]

  exprEnd:
    - match: '{{endOfExpr}}'
      # scope: entity.name.jlf
      scope: punctuation.section.parens.end.jlf
      pop: true
    - include: illegalInclude

  expr:
    - include: exprInclude
    - include: illegalInclude

  # exprContent:
  #   - include: pathInclude
  #   - match: '{{any}}'
  #     set: [exprTernaryMayBegin, exprTail, value]

  exprTail:
    - match: '[\+\-](\s|$)'
      scope: keyword.operator.arithmetic.jlf
      set: [exprSumTail, value]
    - match: '[\*\/](\s|$)'
      scope: keyword.operator.arithmetic.jlf
      set: [exprMulTail, value]
    - match: '(\|\|)'
      scope: keyword.operator.arithmetic.jlf
      set: [exprOrTail, value]
    - match: '(&&)'
      scope: keyword.operator.arithmetic.jlf
      set: [exprAndTail, value]
    - match: '(==|!=|<=|>=)(\s|$)'
      scope: keyword.operator.logical.jlf
      set: [value]
    - match: '{{defStarter}}'
      scope: keyword.jlf
      set: [pathNextSegment, defBegin]
    - match: '\['
      scope: punctuation.section.bracket.begin.jlf
      # scope: keyword.jlf
      set: [pathNextSegment, pathTailIteratorEnd, pathTailIteratorCondition, pathTailIteratorNegation]
    - match: '(?=\|)'
      set: pathNextSegment
    - match: '{{any}}'
      pop: true

  exprTernaryMayBeginInclude:
    - match: '\?:'
      scope: keyword.jlf
      set: [exprTernaryElseCase, value]
    - match: '\?'
      scope: keyword.jlf
      set:
        - match: '(?={{endOfExpr}})'
          pop: true
        - match: '{{any}}'
          set: [exprTernaryElseCase, value, exprTernaryDelimiter, value]

  exprTernaryMayBegin:
    - match: '\?:'
      scope: keyword.jlf
      set: [exprTernaryElseCase, value]
    - match: '\?'
      scope: keyword.jlf
      set:
        - match: '(?={{endOfExpr}})'
          pop: true
        - match: '{{any}}'
          set: [exprTernaryElseCase, value, exprTernaryDelimiter, value]
    - match: '{{any}}'
      pop: true

  exprTernaryIf:
    - match: '\?'
      scope: keyword.jlf
      pop: true
    - include: illegalInclude

  exprTernaryElseCase:
    - include: exprTernaryMayBeginInclude
    - match: '(?=[\+\-\*\/]|\|\||&&|==|!=|<=|>=)'
      push: [value, exprTernaryDelimiter, value, exprTernaryIf, exprTail]
    - match: '{{any}}'
      pop: true

  exprTernaryDelimiter:
    - match: ':'
      pop: true
    - include: illegalInclude

  exprSumTail:
    - match: '[\+\-](\s|$)'
      scope: keyword.operator.arithmetic.jlf
      push: value
    - match: '{{any}}'
      pop: true

  exprMulTail:
    - match: '[\+\-](\s|$)'
      scope: keyword.operator.arithmetic.jlf
      push: value
    - match: '{{any}}'
      pop: true

  exprOrTail:
    - match: '(\|\|)'
      scope: keyword.operator.arithmetic.jlf
      push: value
    - match: '{{any}}'
      pop: true

  exprAndTail:
    - match: '(&&)'
      scope: keyword.operator.arithmetic.jlf
      push: value
    - match: '{{any}}'
      pop: true

# =============================================================================

  intInclude:
    - match: '{{int}}'
      scope: constant.numeric.jlf
      pop: true

# =============================================================================

  # stringValue:
  #   - include: stringInclude
  #   - include: exprInclude
  #   - include: illegalInclude

  # stringSubExpr:
  #   - meta_include_prototype: false
  #   - match: '{{beginOfExpr}}'
  #     scope: punctuation.section.parens.begin.jlf
  #     set: [exprEnd, stringValue]

# =============================================================================

  escapeInclude:
    - meta_include_prototype: false
    - match: '(?=\\$)'
      set:
        - include: illegalInclude
    - match: '\\{{escapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '\\"'
      scope: constant.character.escape.jlf
      push:
        - match: '"'
          scope: constant.character.escape.jlf
          pop: true
    - match: '(\\).'
      captures:
        1: comment.jlf

  nonQuotedStringTailInclude:
    - meta_include_prototype: false
    - match: '{{escapeStarter}}(?={{beginOfExpr}})'
      scope: keyword.jlf
      push: expr
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '({{escapeStarter}}){{endOfNonQuotedString}}'
      captures:
        1: constant.character.escape.jlf
    - include: escapeInclude

  quotedInclude:
    - meta_include_prototype: false
    - match: '{{escapeStarter}}u'
      push:
        - meta_scope: constant.character.escape.jlf
        - match: '[0-9a-fA-F]{4}'
          pop: true
        - include: illegalInclude
    - match: '{{escapeStarter}}{{jsonQuotedEscapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '({{escapeStarter}})({{jsonQuotedEscapeRunesAsIs}})'
      captures:
        1: constant.character.escape.jlf
    - match: '({{escapeStarter}})([{{doubleQuotedValidRune}}])'
      captures:
        1: comment.jlf
    - match: '(?={{escapeStarter}}|[^{{doubleQuotedValidRune}}])'
      set:
        - include: illegalInclude
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.end.jlf
      pop: true

  quotedStringInclude:
    - meta_include_prototype: false
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.jlf
        - match: '{{escapeStarter}}(?={{beginOfExpr}})'
          scope: keyword.jlf
          push: expr
        - include: quotedInclude

# =============================================================================

  valueInclude:
    - meta_include_prototype: false
    - include: simplePathInclude
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: mayBeRange
    - match: '(?={{beginOfExpr}})'
      set: [mayBeRange, expr]
    - include: mapInclude
    - include: defInclude
    - include: arrayInclude
    - include: boolInclude
    - include: nilInclude
    - include: stringInclude
    # - include: varSpecInclude
    # - include: macroInclude

  # macroInclude:
  #   - meta_include_prototype: false
  #   - include: varSpecInclude
  #   - match: '{{varSpecStarter}}'
  #     scope: keyword.jlf
  #     set: [ macroArgs, macroSpec ]

  # macroSpec:
  #   - match: '{{beginOfArgs}}'
  #     scope: punctuation.section.parens.begin.jlf
  #     set:
  #       - meta_include_prototype: false
  #       - match: '{{endOfArgs}}'
  #         pop: true
  #       - match: '{{any}}'
  #         push: [commaSeparator, value]
  #   - include: illegalInclude

  # macroArgs:
  #   - match: '{{beginOfArgs}}'
  #     scope: keyword.jlf
  #     set:
  #       - match: '{{endOfArgs}}'
  #         scope: keyword.jlf
  #         pop: true
  #       - match: '{{any}}'
  #         push: [commaSeparator, value]
  #   - include: illegalInclude

  value:
    - include: valueInclude
    - include: illegalInclude

  mayBeRange:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      set: numberValue
    - match: '{{any}}'
      pop: true

# =====================================

  stringInclude:
    - meta_include_prototype: false
    - include: quotedStringInclude
    - match: '{{beginOfNonQuotedString}}'
      set:
        - meta_include_prototype: false
        - meta_scope: string.jlf
        - include: nonQuotedStringTailInclude

# =====================================

  mapInclude:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfMap}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [ commaSeparator, value, keySeparator, key ]

  key:
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - include: quotedInclude
    - match: '{{beginOfNonQuotedKey}}'
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '(?={{endOfNonQuotedKey}})'
          pop: true
        - match: '(\\){{endOfNonQuotedKey}}'
          captures:
            1: constant.character.escape.jlf
        - include: escapeInclude
    - include: illegalInclude

  keySeparator:
    - match: '{{keySeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  commaSeparator:
    - match: '{{commaSeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =====================================

  arrayInclude:
    - meta_include_prototype: false
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
          - match: '{{endOfArray}}'
            scope: punctuation.section.block.end.jlf
            pop: true
          - match: '{{any}}'
            push: [commaSeparator, value]

# =====================================

  boolInclude:
    - meta_include_prototype: false
    - match: \b{{bool}}\b
      scope: constant.language.jlf
      pop: true

# =====================================

  nilInclude:
    - meta_include_prototype: false
    - match: \b{{nil}}\b
      scope: constant.language.jlf
      pop: true

# =============================================================================

  rangeValue:
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: [ numberValue, rangeSeparator ]
    - match: '(?={{beginOfExpr}})'
      set: [mayBeRange, expr]
    - include: illegalInclude

  rangeSeparator:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      pop: true
    - include: illegalInclude

  numberValue:
    - include: numberInclude
    - include: exprInclude
    - include: illegalInclude

  numberInclude:
    - match: '{{number}}'
      scope: constant.numeric.jlf
      pop: true

# =============================================================================

  stringsExprValue:
    - match: '\{'
      scope: keyword.jlf
    # - match: '{{beginOfExpr}}'
    #   scope: punctuation.section.parens.begin.jlf
    #   set:
    #     - include: pathExprInclude
    #     - include: exprInclude
        # - match: '{{any}}'
          # set: [exprEnd, stringsExprTail, stringsExprValue]
    # - include: exprInclude
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfArray}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [ commaSeparator, stringsExprValue ]
    - include: stringInclude
    - include: illegalInclude

  stringsExprTail:
    - match: '(\+|\-)\s'
      scope: keyword.operator.arithmetic.jlf
      push: [stringsExprTail, stringsExprValue]
    - match: '{{any}}'
      pop: true

# =============================================================================

  defInclude:
    - meta_include_prototype: false
    - match: '{{defStarter}}'
      scope: keyword.jlf
      set: defBegin

  defBegin:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: keyOfDef
    - match: '{{any}}'
      set: defType

  keyOfDef:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      push: [commaSeparator, defType, keySeparator]
    - match: \b(enum|keys)\b
      scope: keyword.jlf
      # push: [commaSeparator, stringsExprValue, keySeparator]
      push: [commaSeparator, stringsExprValue, keySeparator]
    - match: \bkeysDef\b
      scope: keyword.jlf
      push: [commaSeparator, defKeysDefExprValue, keySeparator]
    - match: \b(elemDef|arrayElemDef)\b
      scope: keyword.jlf
      push: [commaSeparator, defValue, keySeparator]
    - match: \brange\b
      scope: keyword.jlf
      push: [commaSeparator, rangeValue, keySeparator]
    - match: \bisOptional\b
      scope: keyword.jlf
      push: [commaSeparator, boolValue, keySeparator]
    - match: \bdefault\b
      scope: keyword.jlf
      push: [commaSeparator, value, keySeparator]
    - include: illegalInclude

  defType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfArray}}'
          pop: true
        - match: \b{{defTypeMulti}}|{{defTypeSingle}}\b
          scope: variable.parameter
        - include: illegalInclude
    - include: illegalInclude

# =============================================================================

  defKeysDefExprValue:
    - include: simplePathInclude
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: defKeysTail
    - include: exprInclude
    # - match: '{{beginOfExpr}}'
    #   scope: punctuation.section.parens.begin.jlf
    #   set:
    #     - include: pathExprInclude
    #     - match: '{{any}}'
    #       set: [exprEnd, defKeysDefExprTail, defKeysDefExprValue]
    - include: illegalInclude

  # defKeysDefExprTail:
  #   - match: '(\+)\s'
  #     scope: keyword.operator.arithmetic.jlf
  #     push: defKeysDefExprValue
  #   - match: '{{any}}'
  #     pop: true

# =============================================================================

  defKeysTail:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      push: [ defValue, keySeparator, optionalSign, key]

  optionalSign:
    - meta_include_prototype: false
    - match: '{{pathOptionalSign}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =============================================================================

  boolValue:
    - include: boolInclude
    - include: simplePathInclude
    - include: exprInclude
    - include: illegalInclude

# =============================================================================

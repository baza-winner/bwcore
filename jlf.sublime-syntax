%YAML 1.2
---
name: JLF
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions:
  - jlf
scope: source.jlf

variables:
  space: '[\s]+'
  beginOfSingleLineComment: '//'
  beginOfMultiLineComment: '/\*'
  endOfMultiLineComment: '\*/'

  number: '[\+\-]?\d+(?:\.\d+)?'
  # id: '[a-zA-Z_\./~]([a-zA-Z_\./\-~\d]*)'
  id: '[a-zA-Z_]([a-zA-Z_\d\.-]*)'
  bool: true|false
  nil: nil

  assignSeparator: '(=>|:?=|:)'
  commaSeparator: ','

  beginOfMap: '\{'
  endOfMap: '\}'

  beginOfArray: '\['
  endOfArray: '\]'

  any: '(?=.)'

  doubleQuotedStringDelimiter: '"'
  singleQuotedStringDelimiter: "'"
  doubleEscapeRunes: "abfnrtv"
  singleEscapeRunes: "\\\\\"'"

  escapeStarter: '\\'
  macroDefStarter: '\#'
  macroSpecStarter: '{{macroDefStarter}}'
  varSpecStarter: '\$'
  funcStarter: '\&'
  fileSpecStarter: '%'
  defStarter: '\^'
  pathStarter: '\*'

  beginOfSubExpr: '\('
  endOfSubExpr: '\)'

  # beginOfPath: '\('
  # endOfPath: '\)'
  int: '[-+]?\d+'

  pathSegmentSeparator: '\|'
  rangeSeparator: '\.\.'

  defTypeSingle: 'Array|Map|String|Int|Number|Bool'
  defTypeMulti: 'ArrayOf'

  pathUpperLevel: '\.\.'
  pathCurrLevel: '\.'
  pathOptionalSign: '\?'
  pathDefaultValueStarter: ':'
  newline: '\n'
  endOfNonQuotedString: '{{space}}|{{endOfSubExpr}}|{{pathSegmentSeparator}}|{{endOfMap}}|{{endOfArray}}'
  escapeRunes: '[abfnrtv]'
  # varScope: 'string.unquoted'

# =============================================================================
# =============================================================================

contexts:

  prototype:
    - include: space

  space:
    - meta_include_prototype: false
    - match: '{{space}}'
    - match: '{{beginOfSingleLineComment}}'
      scope: punctuation.definition.comment.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment.line.jlf
        - match: $
          pop: true
    - match: '{{beginOfMultiLineComment}}'
      scope: punctuation.definition.comment.begin.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment
        - match: '{{endOfMultiLineComment}}'
          scope: punctuation.definition.comment.end.jlf
          pop: true

  illegal:
    - meta_include_prototype: false
    - match: .
      scope: invalid.illegal.jlf

# =============================================================================

  main:
    - match: '({{macroDefStarter}})({{defStarter}})'
      captures:
        1: storage.type.jlf
        2: variable.parameter
      set: [main, defOrExpr, assignSeparator]
    - match: '{{macroDefStarter}}{{id}}'
      scope: storage.type.jlf
      set: [main, expr, assignSeparator, macroDefParams]
    - match: '{{any}}'
      set: [end, value]

  end:
    - match: '({{macroDefStarter}})({{defStarter}})'
      captures:
        1: keyword.jlf
        2: keyword.jlf
      set: [end, defOrExpr, assignSeparator]
    - match: '{{macroDefStarter}}'
      scope: keyword.jlf
      set: [end, expr, assignSeparator, var]
    - include: illegal

  # assignSeparator:
  #   - match: '{{assignSeparator}}'
  #     scope: comment.jlf
  #     pop: true
  #   - match: '{{any}}'
  #     pop: true

# =============================================================================

  macroDefParams:
    - meta_include_prototype: false
    - match: '\('
      set:
        - match: '{{macroDefStarter}}{{id}}'
          scope: storage.type.jlf
          push: commaSeparator
        - match: '\)'
          pop: true
    - match: '{{any}}'
      pop: true

  # commaSeparator:
  #   - match: ','
  #     scope: comment.jlf
  #     pop: true
  #   - match: '{{any}}'
  #     pop: true

# =============================================================================

  argTail:
    - match: '\)'
      pop: true
    - match: '{{any}}'
      set: expr

  varSpec:
    - meta_include_prototype: false
    - match: '\\(?={{beginOfSubExpr}})'
      scope: keyword.jlf
      push: subExpr
    - match: '\\\n'
      scope: invalid.illegal.jlf
    - match: '\\{{escapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '(\\)({{endOfNonQuotedString}})'
      captures:
        1: constant.character.escape.jlf
        2: entity.name.jlf
    - match: '(\\)(.)'
      captures:
        1: comment.jlf
        2: entity.name.jlf
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '\('
      scope: punctuation.section.parens.begin.jlf
      set: [argTail, commaSeparator, expr]
    - match: '.'
      scope: entity.name.jlf
    - include: illegal

  macroSpec:
    - meta_include_prototype: false
    - match: '\\(?={{beginOfSubExpr}})'
      scope: keyword.jlf
      push: subExpr
    - match: '\\\n'
      scope: invalid.illegal.jlf
    - match: '\\{{escapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '(\\)({{endOfNonQuotedString}})'
      captures:
        1: constant.character.escape.jlf
        2: storage.type.jlf
    - match: '(\\)(.)'
      captures:
        1: comment.jlf
        2: storage.type.jlf
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '\('
      scope: punctuation.section.parens.begin.jlf
      set: [argTail, commaSeparator, expr]
    - match: '.'
      scope: storage.type.jlf
    - include: illegal

  fileSpec:
    - meta_include_prototype: false
    - match: '\\(?={{beginOfSubExpr}})'
      scope: keyword.jlf
      push: subExpr
    - match: '\\\n'
      scope: invalid.illegal.jlf
    - match: '\\{{escapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '(\\)({{endOfNonQuotedString}})'
      captures:
        1: constant.character.escape.jlf
        2: meta.path.jlf
    - match: '(\\)(.)'
      captures:
        1: comment.jlf
        2: meta.path.jlf
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '\('
      scope: punctuation.section.parens.begin.jlf
      set: [argTail, commaSeparator, expr]
    - match: '.'
      scope: meta.path.jlf
    - include: illegal

  pathSegmentSpec:
    - meta_include_prototype: false
    - match: '\\(?={{beginOfSubExpr}})'
      scope: keyword.jlf
      push: subExpr
    - match: '\\\n'
      scope: invalid.illegal.jlf
    - match: '\\{{escapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '(\\)({{endOfNonQuotedString}})'
      captures:
        1: constant.character.escape.jlf
        2: support.function.jlf
    - match: '(\\)(.)'
      captures:
        1: comment.jlf
        2: support.function.jlf
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '\('
      scope: punctuation.section.parens.begin.jlf
      set: [argTail, commaSeparator, expr]
    - match: '.'
      scope: support.function.jlf
    - include: illegal

  varExpr:
    - match: '{{varSpecStarter}}'
      scope: entity.name.jlf
      set: [exprTail, pathTail, varSpec]
    - match: '{{macroSpecStarter}}'
      scope: storage.type.jlf
      set: [exprTail, pathTail, macroSpec]
    - match: '{{fileSpecStarter}}'
      scope: meta.path.jlf
      set: [exprTail, pathTail, fileSpec]
    - match: '{{pathStarter}}'
      scope: keyword.jlf
      # scope: entity.name.jlf
      set: [exprTail, pathTail, pathSegmentSpec]

  expr:
    - include: varExpr
    - include: value

  exprTail:
    - match: '\b(\+|\-|\*|/)\b'
      set: [exprTail, expr]
    - match: '{{any}}'
      pop: true
    - include: illegal

  subExpr:
    - meta_include_prototype: false
    - match: '{{beginOfSubExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set: [subExprEnd, expr]

  subExprEnd:
    - match: '{{endOfSubExpr}}'
      scope: punctuation.section.parens.end.jlf
      # scope: variable.parameter.jlf
      pop: true

# =============================================================================

  # fileSpec:
  #   - meta_include_prototype: false
  #   # - include: subExpr
  #   - match: '\('
  #     set: [fileSpec, subExprEnd, expr]
  #   - match: '{{id}}'
  #     scope: meta.path.jlf
  #   - match: '{{any}}'
  #     pop: true

  pathTail:
    - match: '{{pathOptionalSign}}'
      scope: keyword.jlf
      set: [nextPathSegment, pathDefaultValue]
        # - meta_include_prototype: false
        # - match: '{{pathDefaultValueStarter}}'
        #   scope: keyword.jlf
        #   set: [nextPathSegment, value]
        # - match: '{{any}}'
        #   set: nextPathSegment

  pathDefaultValue:
    - meta_include_prototype: false
    - match: '{{pathDefaultValueStarter}}'
      scope: keyword.jlf
      set: value
    - match: '{{any}}'
      pop: true

  nextPathSegment:
    - match: '{{pathSegmentSeparator}}'
      scope: keyword.jlf
      set:
        - match: '({{defStarter}})'
          scope: keyword.jlf
          set: defBegin
        - match: '{{any}}'
          set: [ pathTail, pathSegment]
    - match: '{{any}}'
      pop: true

    # - match: '{{pathSegmentSeparator}}'
    #   scope: keyword.jlf
    #   set:
    #     - match: '{{defStarter}}'
    #       scope: variable.parameter.jlf
    #       set: [ defBegin ]
    #     - match: '{{any}}'
    #       push:
    #         - include: pathBeginOnlySegment
    #         - include: pathCommonSegment
    #         - include: illegal
    #       # set: [ pathTail, pathSegment ]
    # - match: '{{any}}'
    #   pop: true

  # pathSegment:
  #   # - match: '{{int}}'
  #   #   scope: constant.numeric.jlf
  #   #   pop: true
  #   # - include: subExpr
  #   # - include: nonQuotedString
  #   - include: pathSegmentHelper
  #   - include: illegal

  # pathSegmentHelper:
  #   - meta_include_prototype: false
  #   - match: '{{int}}'
  #     scope: constant.numeric.jlf
  #     pop: true
  #   - include: subExpr
  #   - include: nonQuotedString

# =============================================================================

  nonQuotedKey:
    - match: '\\.'
      scope: constant.character.escape.jlf
    - match: '{{space}}|\)|:|=>|{|\['
      pop: true
    - match: '.'
      scope: string.jlf

  nonQuotedString:
    - meta_include_prototype: false
    - include: nonBoolNil
    - include: nonQuotedStringBegin
    - include: nonQuotedStringContent

  nonQuotedStringBegin:
    - meta_include_prototype: false
    - match: '(\\)([^\)\n])'
      captures:
        1: keyword.jlf
        2: string.jlf
      set: nonQuotedStringTail
    - match: '[a-zA-Z_]'
      scope: string.jlf
      set: nonQuotedStringTail

  nonQuotedStringContent:
    - meta_include_prototype: false
    - match: '\\(?={{beginOfSubExpr}})'
      scope: keyword.jlf
      push: subExpr
    - match: '\\\n'
      scope: invalid.illegal.jlf
      set: nonQuotedStringTail
    - match: '\\[abfnrtv]'
      scope: constant.character.escape.jlf
      set: nonQuotedStringTail
    - match: '(\\)({{endOfNonQuotedString}})'
      captures:
        1: constant.character.escape.jlf
        2: string.jlf
      set: nonQuotedStringTail
    - match: '(\\)(.)'
      captures:
        1: comment.jlf
        2: string.jlf
      set: nonQuotedStringTail

  nonQuotedStringTailOnly:
    - meta_include_prototype: false
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '.'
      scope: string.jlf

  nonQuotedStringTail:
    - meta_include_prototype: false
    - include: nonQuotedStringContent
    - include: nonQuotedStringTailOnly
    - include: illegal

# =============================================================================

  # varValue:
  #   - meta_include_prototype: false
  #   - match: '{{fileSpecStarter}}'
  #     scope: meta.path.jlf
  #     set:
  #       - meta_include_prototype: false
  #       - include: nonQuotedStringTail
  #   - match: '{{macroDefStarter}}'
  #     scope: entity.name.jlf
  #     set:
  #       - meta_include_prototype: false
  #       # - meta_scope: entity.name.jlf
  #       - include: nonQuotedStringTail
  #   - match: '{{pathStarter}}'
  #     scope: keyword.jlf
  #     set: pathSegment

  value:
    # - match: '{{fileSpecStarter}}'
    #   scope: meta.path.jlf
    #   set: nonQuotedStringTail
    # - match: '{{macroDefStarter}}'
    #   scope: entity.name.jlf
    #   set: nonQuotedString
    # - match: '{{pathStarter}}'
    #   scope: keyword.jlf
    #   set: pathSegment
    # - include: varValue
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: mayBeRange
    - match: '{{beginOfSubExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set: [mayBeRange, subExprEnd, expr]
    # - match: '{{beginOfPath}}'
    #   scope: punctuation.section.block.begin.jlf
    #   set: [ mayBeRange, endOfPathSegment, pathBeginSegment ]
    # - include: path
    - include: map
    - include: def
    - include: array
    # - include: arrayOfString
    - include: bool
    - include: nil
    # - match: '{{any}}'
    #   set:
    #     - meta_scope: string.jlf
    #     - include: nonQuotedString
    - include: nonQuotedString
    - include: quotedString
    - include: illegal

  mayBeRange:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      set: rangeMaxValue
    - match: '{{any}}'
      pop: true

# =====================================

  nonBoolNil:
    - meta_include_prototype: false
    - match: \b{{bool}}|{{nil}}\b
      scope: invalid.illegal.jlf
      pop: true

  string:
    - meta_include_prototype: false
    - include: quotedString
    - include: nonBoolNil
    - match: \b{{id}}\b
      scope: string.quoted.double.jlf
      pop: true

  quotedString:
    - meta_include_prototype: false
    # - match: '{{singleQuotedStringDelimiter}}'
    #   scope: punctuation.definition.string.begin.jlf
    #   set:
    #     - meta_include_prototype: false
    #     - meta_scope: string.quoted.double.jlf
    #     - match: '{{escapeStarter}}'
    #       scope: constant.character.escape.jlf
    #       push:
    #         - meta_include_prototype: false
    #         - match: "[{{singleEscapeRunes}}]"
    #           scope: constant.character.escape.jlf
    #           pop: true
    #         - include: illegal
    #     - match: '{{singleQuotedStringDelimiter}}'
    #       scope: punctuation.definition.string.end.jlf
    #       pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true

# =====================================

  map:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: mapTail

  mapTail:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ mapTail, commaSeparator, value, assignSeparator, key ]

  key:
    - match: '{{singleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{singleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: \b{{id}}\b
      scope: support.function.jlf
      pop: true
    - include: illegal

  assignSeparator:
    - match: '{{assignSeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  commaSeparator:
    - match: '{{commaSeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =====================================

  def:
    - meta_include_prototype: false
    - match: '{{defStarter}}'
      scope: keyword.jlf
      set: defBegin

# =====================================

  array:
    - meta_include_prototype: false
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set: arrayTail

  arrayTail:
    - match: '{{endOfArray}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ arrayTail, commaSeparator, value]

# =====================================

  bool:
    - meta_include_prototype: false
    - match: \b{{bool}}\b
      scope: constant.language.jlf
      pop: true

# =====================================

  nil:
    - meta_include_prototype: false
    - match: \b{{nil}}\b
      scope: constant.language.jlf
      pop: true

# =============================================================================

  rangeValue:
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: [ rangeMaxValue, rangeSeparator ]
    - match: '(?={{beginOfSubExpr}})'
      set: [ rangeMaxValue, rangeSeparator, subExpr ]
    - include: illegal

  rangeSeparator:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      pop: true
    - include: illegal

  rangeMaxValue:
    - meta_include_prototype: false
    - match: '{{number}}'
      scope: constant.numeric.jlf
      pop: true
    - include: subExpr
    - include: illegal

# =============================================================================

  strings:
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set: stringsTail
    - include: stringsItem
    - include: illegal

  stringsTail:
    - match: '{{endOfArray}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ stringsTail, commaSeparator, stringsItem]

  stringsItem:
    - include: string
    - include: path
    - include: illegal

# =============================================================================

  # path:
  #   - meta_include_prototype: false
  #   - match: '{{fileSpecStarter}}'
  #     scope: keyword.jlf
  #     set: [ pathTail, pathFileSpec ]
  #   - match: '{{macroDefStarter}}'
  #     scope: keyword.jlf
  #     set: [ pathTail, pathVar ]
  #   - match: '{{pathStarter}}'
  #     scope: keyword.jlf
  #     set:
  #       - meta_include_prototype: false
  #       - match: '{{id}}'
  #         scope: support.function.jlf
  #         set:

  # pathSegment:


      # set: [ pathTail, pathVar ]
    # - match: '{{pathCurrLevel}}(?={{pathSegmentSeparator}})'
    #   scope: meta.path
    #   pop: true

  # pathVar:

  # pathFileSpec:
  #   - meta_include_prototype: false
  #   - include: subExpr
  #   - match: '{{id}}'
  #     scope: meta.path.jlf
  #   # - match: '{{singleQuotedStringDelimiter}}'
  #   #   scope: keyword.jlf
  #   #   push:
  #   #     - meta_include_prototype: false
  #   #     - match: '{{escapeStarter}}'
  #   #       scope: constant.character.escape.jlf
  #   #       push:
  #   #         - meta_include_prototype: false
  #   #         - match: "[{{singleEscapeRunes}}]"
  #   #           scope: constant.character.escape.jlf
  #   #           pop: true
  #   #         - include: illegal
  #   #     - match: '{{singleQuotedStringDelimiter}}'
  #   #       scope: keyword.jlf
  #   #       pop: true
  #   #     - match: .
  #   #       scope: meta.path
  #   - match: '{{doubleQuotedStringDelimiter}}'
  #     scope: keyword.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - match: '{{escapeStarter}}'
  #         scope: constant.character.escape.jlf
  #         push:
  #           - meta_include_prototype: false
  #           - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
  #             scope: constant.character.escape.jlf
  #             pop: true
  #           - include: illegal
  #       - match: '{{doubleQuotedStringDelimiter}}'
  #         scope: keyword.jlf
  #         pop: true
  #       - match: .
  #         scope: meta.path
  #   - match: '{{escapeStarter}}'
  #     scope: constant.character.escape.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - meta_include_prototype: false
  #       - match: '[\s]'
  #         scope: constant.character.escape.jlf
  #         pop: true
  #       - include: illegal
  #   - match: .
  #     scope: meta.path
  #   - include: illegal
  #   - match: '{{any}}'
  #     pop: true

    # - match: '{{beginOfPath}}'
    #   scope: punctuation.section.parens.begin.jlf
    #   set: [endOfPathSegment, pathBeginSegment]

  pathBeginSegment:
    - meta_include_prototype: false
    - include: pathBeginOnlySegment
    - include: pathCommonSegment
    - include: illegal

  pathBeginOnlySegment:
    - meta_include_prototype: false
    # - match: '{{fileSpecStarter}}'
    #   scope: keyword.jlf
    #   set: fileSpec
    - match: '{{pathCurrLevel}}(?={{pathSegmentSeparator}})'
      scope: meta.path
      pop: true

  pathCommonSegment:
    - meta_include_prototype: false
    # - match: '{{varSpecStarter}}'
    #   scope: entity.name.jlf
    #   set: varSpec
    # - match: '{{macroSpecStarter}}'
    #   scope: storage.type.jlf
    #   set: macroSpec
    - match: '{{pathUpperLevel}}(?={{pathSegmentSeparator}})'
      scope: meta.path
      pop: true
    - match: '{{int}}'
      scope: meta.path
      pop: true
    - match: '{{id}}'
      scope: support.function.jlf
      pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true

  pathSegment:
  #   - include: path
    - include: pathCommonSegment
    - include: illegal

  # endOfPath:
  #   - meta_include_prototype: false
  #   - match: '{{endOfPath}}'
  #     scope: punctuation.section.parens.end.jlf
  #     pop: true

  # endOfPathSegment:
  #   - match: '{{pathOptionalSign}}'
  #     scope: keyword.jlf
  #     set:
  #       - meta_include_prototype: false
  #       - match: '{{pathDefaultValueStarter}}'
  #         set: [nextPathSegment, value]
  #       - match: '{{any}}'
  #         set: nextPathSegment
    # - match: '{{any}}'
    #   set: nextPathSegment

  # pathOptionalSign:
  #   - match: '(?=({{pathSegmentSeparator}}|{{endOfPath}}))'
  #     set: nextPathSegment
  #   - match: '{{any}}'
  #     set: [nextPathSegment, value]

  # nextPathSegment:
  #   # - include: endOfPath
  #   - match: '{{pathSegmentSeparator}}'
  #     scope: keyword.jlf
  #     set: nextPathSegmentHelper
  #   - match: '{{any}}'
  #     pop: true

    # - include: illegal

  # nextPathSegmentHelper:
  #   - match: '({{defStarter}})'
  #     scope: keyword.jlf
  #     set: [ pathEnd, defBegin]
  #   # - match: '{{beginOfPath}}'
  #   #   scope: punctuation.section.block.begin.jlf
  #   #   set: [ pathEnd, endOfPathSegment, pathBeginSegment, ]
  #   - match: '{{any}}'
  #     set: [ endOfPathSegment, pathSegment]

  # pathFuncName:
  #   - meta_include_prototype: false
  #   - match: \b{{id}}\b
  #     scope: entity.function.jlf
  #     pop: true
  #   # - match: '{{singleQuotedStringDelimiter}}'
  #   #   scope: punctuation.definition.string.begin.jlf
  #   #   set:
  #   #     - meta_include_prototype: false
  #   #     - meta_scope: entity.function.jlf
  #   #     - match: '{{escapeStarter}}'
  #   #       scope: constant.character.escape.jlf
  #   #       push:
  #   #         - meta_include_prototype: false
  #   #         - match: "[{{singleEscapeRunes}}]"
  #   #           scope: constant.character.escape.jlf
  #   #           pop: true
  #   #         - include: illegal
  #   #     - match: '{{singleQuotedStringDelimiter}}'
  #   #       scope: punctuation.definition.string.end.jlf
  #   #       pop: true
  #   - match: '{{doubleQuotedStringDelimiter}}'
  #     scope: punctuation.definition.string.begin.jlf
  #     set:
  #       - meta_include_prototype: false
  #       - meta_scope: entity.function.jlf
  #       - match: '{{escapeStarter}}'
  #         scope: constant.character.escape.jlf
  #         push:
  #           - meta_include_prototype: false
  #           - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
  #             scope: constant.character.escape.jlf
  #             pop: true
  #           - include: illegal
  #       - match: '{{doubleQuotedStringDelimiter}}'
  #         scope: punctuation.definition.string.end.jlf
  #         pop: true
  #   - include: illegal

  # pathFuncArg:
  #   - match: '(?=({{pathSegmentSeparator}}|{{endOfPath}}))'
  #     pop: true
  #   - match: '{{any}}'
  #     set: value

  pathEnd:
    - include: endOfPath
    - include: illegal

  var:
    - meta_include_prototype: false
    - match: '{{id}}'
      # scope: entity.name.jlf
      scope: storage.type
      # scope: '{{varScope}}'
      pop: true
    # - match: '{{singleQuotedStringDelimiter}}'
    #   scope: punctuation.definition.string.begin.jlf
    #   set:
    #     - meta_include_prototype: false
    #     - meta_scope: entity.name.jlf
    #     - match: '{{escapeStarter}}'
    #       scope: constant.character.escape.jlf
    #       push:
    #         - meta_include_prototype: false
    #         - match: "[{{singleEscapeRunes}}]"
    #           scope: constant.character.escape.jlf
    #           pop: true
    #         - include: illegal
    #     - match: '{{singleQuotedStringDelimiter}}'
    #       scope: punctuation.definition.string.end.jlf
    #       pop: true
    # - match: '{{doubleQuotedStringDelimiter}}'
    #   scope: punctuation.definition.string.begin.jlf
    #   set:
    #     - meta_include_prototype: false
    #     - meta_scope: entity.name.jlf
    #     - match: '{{escapeStarter}}'
    #       scope: constant.character.escape.jlf
    #       push:
    #         - meta_include_prototype: false
    #         - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
    #           scope: constant.character.escape.jlf
    #           pop: true
    #         - include: illegal
    #     - match: '{{doubleQuotedStringDelimiter}}'
    #       scope: punctuation.definition.string.end.jlf
    #       pop: true
    # - include: illegal

  # pathFileSpec:
  #   - meta_include_prototype: false
  #   - match: '(?={{pathSegmentSeparator}}|{{endOfPath}}|{{pathOptionalSign}}|{{newline}})'
  #     pop: true
  #   - match: '{{beginOfPath}}'
  #     scope: punctuation.section.parens.begin.jlf
  #     set: [ pathFileSpec, endOfPathSegment, pathBeginSegment]
  #   - match: '{{singleQuotedStringDelimiter}}'
  #     scope: keyword.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - match: '{{escapeStarter}}'
  #         scope: constant.character.escape.jlf
  #         push:
  #           - meta_include_prototype: false
  #           - match: "[{{singleEscapeRunes}}]"
  #             scope: constant.character.escape.jlf
  #             pop: true
  #           - include: illegal
  #       - match: '{{singleQuotedStringDelimiter}}'
  #         scope: keyword.jlf
  #         pop: true
  #       - match: .
  #         scope: meta.path
  #   - match: '{{doubleQuotedStringDelimiter}}'
  #     scope: keyword.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - match: '{{escapeStarter}}'
  #         scope: constant.character.escape.jlf
  #         push:
  #           - meta_include_prototype: false
  #           - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
  #             scope: constant.character.escape.jlf
  #             pop: true
  #           - include: illegal
  #       - match: '{{doubleQuotedStringDelimiter}}'
  #         scope: keyword.jlf
  #         pop: true
  #       - match: .
  #         scope: meta.path
  #   - match: '{{escapeStarter}}'
  #     scope: constant.character.escape.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - meta_include_prototype: false
  #       - match: '[\s]'
  #         scope: constant.character.escape.jlf
  #         pop: true
  #       - include: illegal
  #   - match: .
  #     scope: meta.path
  #   - include: illegal

# =============================================================================

  defBegin:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: keyOfDef
    - include: defType
    - include: illegal

  defOrExpr:
    # - include: path
    - include: varExpr
    # - include: varValue
    - include: defBegin

  keyOfDef:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, defType, assignSeparator]
    - match: \benum\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, strings, assignSeparator]
    - match: \bkeysDef\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, defKeysDef, assignSeparator]
    - match: \bkeys\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, strings, assignSeparator]
    - match: \b(elemDef|arrayElemDef)\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, defOrExpr, assignSeparator]
    - match: \brange\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, rangeValue, assignSeparator]
    - match: \bisOptional\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, boolValue, assignSeparator]
    - match: \bdefault\b
      scope: keyword.jlf
      set: [keyOfDef, commaSeparator, expr, assignSeparator]
    - include: illegal

  defType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set: defTypeAsArray
    - include: illegal

  defTypeAsArray:
    - match: '{{endOfArray}}'
      pop: true
    - include: defTypeAsArrayItem
    - include: illegal

  defTypeAsArrayItem:
    - meta_include_prototype: false
    - match: \b{{defTypeMulti}}|{{defTypeSingle}}\b
      scope: variable.parameter

  defKeysDef:
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: defKeysTail
    - include: illegal

  defKeysTail:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ defKeysTail, defOrExpr, assignSeparator, optionalSign, keyOfDefKeys]

  keyOfDefKeys:
    - include: key
    - include: illegal

  optionalSign:
    - meta_include_prototype: false
    - match: '{{pathOptionalSign}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  boolValue:
    - include: bool
    - include: illegal

# =============================================================================

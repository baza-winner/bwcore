%YAML 1.2
---
name: JLF
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions: [ jlf ]
scope: source.jlf

variables:
  space: '[\s]+'
  beginOfSingleLineComment: '//'
  beginOfMultiLineComment: '/\*'
  endOfMultiLineComment: '\*/'

  any: '(?=.)'

  number: '[\+\-]?\d+(?:\.\d+)?'
  id: '[a-zA-Z_]([a-zA-Z_\d\.-]*)'
  bool: true|false
  nil: nil

  keySeparator: '(\s[=-]>|\s=|:)?(\s|$)'
  commaSeparatorOptional: ','

  beginOfMap: '\{'
  endOfMap: '\}'

  beginOfArray: '\['
  endOfArray: '\]'

  beginOfVarDefBlock: '\('
  endOfVarDefBlock: '\)'
  beginOfExpr: '\('
  endOfExpr: '\)'

  beginOfArgsMap: '\{'
  endOfArgsMap: '\}'

  beginOfArgsArray: '\{'
  endOfArgsArray: '\}'

  beginOfIterator: '\['
  endOfIterator: '\]'

  doubleQuotedStringDelimiter: '"'

  escapeStarter: '\\'
  varStarter: '\$'
  fileSpecStarter: '%'
  defStarter: '\^'
  genStarter: '\&'
  # pathSpecStarter: '\*'
  # varStarter: '[{{fileSpecStarter}}{{varStarter}}{{pathSpecStarter}}]'
  # varStarter: '{{varStarter}}'
  chainSegmentSpecStarter: '[^^\s\(\|\*%]'

  int: '[-+]?\d+'

  pathSegmentSeparator: '\|(?!\|)'
  rangeSeparator: '\.\.'
  negationMark: '!'

  ternaryIf: '\?'
  ternaryDelimiter: ':'

  spaceAfter: '(\s|$)'
  sumOps: '[\+\-]'
  mulOps: '[\*\/]'
  andOp: '(\&\&)'
  orOp: '(\|\|)'
  cmpOps: '(==|!=|<=|>=)'
  defMatchOp: '(=\^)'

  defTypeSingle: 'Array|Map|String|Int|Number|Bool|Range|Def|Gen|Any|AnyBut'
  defTypeMulti: 'ArrayOf'
  spreadOp: '(\.\.\.)'

  optionalEnder: '\?'
  pathDefaultValueStarter: ':'
  beginOfNonQuotedKey: '(?=[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparatorOptional}}])(?!{{endOfNonQuotedKey}})'
  endOfNonQuotedKey: '{{space}}|{{optionalEnder}}|{{beginOfExpr}}|{{endOfExpr}}|{{beginOfMap}}|{{beginOfArray}}|{{keySeparator}}'
  beginOfNonQuotedString: '(?=[\\a-zA-Z_\.])'
  endOfNonQuotedString: '{{space}}|{{optionalEnder}}|{{beginOfExpr}}|{{endOfExpr}}|{{pathSegmentSeparator}}|{{beginOfMap}}|{{beginOfArray}}|{{endOfMap}}|{{endOfArray}}|{{commaSeparatorOptional}}|{{defStarter}}|{{spreadOp}}'
  jsonQuotedEscapeRunes: '[bfnrt]'
  jsonQuotedEscapeRunesAsIs: '["\\/]'
  escapeRunes: '[abfnrtv]'
  nonQuotedKeyBegin: '[^{{beginOfMap}}{{endOfMap}}{{beginOfArray}}{{endOfArray}}{{commaSeparatorOptional}}]'
  doubleQuotedValidRune: '\x{0020}-\x{10ffff}'

# =============================================================================
# =============================================================================

contexts:

  prototype:
    - include: spaceInclude

  spaceInclude:
    - meta_include_prototype: false
    - match: '{{space}}'
    - match: '{{beginOfSingleLineComment}}'
      scope: punctuation.definition.comment.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment.line.jlf
        - match: $
          pop: true
    - match: '{{beginOfMultiLineComment}}'
      scope: punctuation.definition.comment.begin.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment
        - match: '{{endOfMultiLineComment}}'
          scope: punctuation.definition.comment.end.jlf
          pop: true

  illegalInclude:
    - meta_include_prototype: false
    - match: .
      scope: invalid.illegal.jlf

# =============================================================================

  varDefInclude:
    - match: '({{varStarter}})({{defStarter}})'
      captures:
        1: keyword.jlf
        2: variable.parameter.jlf
      push: [defValue, keySeparatorOptional]
    - match: '({{varStarter}})'
      scope: keyword.jlf
      push: [value, keySeparatorOptional, varDefArgsOptional, varName]

  main:
    - match: '{{any}}'
      set: [mainTail, mainArgsOptional]

  mainArgsOptional:
    - match: '({{varStarter}})(?={{beginOfArgsMap}})'
      scope: keyword.jlf
      set: varDefArgsOptional
    - match: '{{any}}'
      pop: true

  mainTail:
    - include: varDefInclude
    - match: '{{any}}'
      set: [end, value]

  end:
    - include: varDefInclude
    - include: illegalInclude

# =============================================================================

  varDefArgsOptional:
    - meta_include_prototype: false
    - match: '{{beginOfArgsMap}}'
      scope: punctuation.section.parens.begin.jlf
      set:
      - match: '{{endOfArgsMap}}'
        scope: punctuation.section.block.end.jlf
        pop: true
      - match: '{{any}}'
        push: [ defValue, keySeparatorOptional, optionalEnderOptional, argName]
    - match: '{{any}}'
      pop: true

  argName:
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: entity.name.variable.jlf
        - include: quotedInclude
    - match: '{{beginOfNonQuotedKey}}'
      set:
        - meta_include_prototype: false
        - meta_scope: entity.name.variable.jlf
        - match: '(?={{endOfNonQuotedKey}})'
          pop: true
        - match: '(\\){{endOfNonQuotedKey}}'
          captures:
            1: constant.character.escape.jlf
        - include: escapeInclude
    - include: illegalInclude

# =============================================================================

  genValue:
    - include: commonValueInclude
    - match: '{{any}}'
      set: [gen, genStarterOptional]

  genStarterOptional:
    - match: '{{genStarter}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  genInclude:
    - meta_include_prototype: false
    - match: '{{genStarter}}'
      scope: keyword.jlf
      set: gen

  gen:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: keyOfGen
    - include: illegalInclude

  keyOfGen:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, genType, keySeparatorOptional]
    - match: \bkey\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, stringValue, keySeparatorOptional]
    - match: \bvalue\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, value, keySeparatorOptional]
    - match: \belem\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, gen, keySeparatorOptional]
    - include: illegalInclude

  genType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true

# =============================================================================

  iteratorNegationOptional:
    - meta_include_prototype: false
    - match: '{{negationMark}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  iteratorConditionOptional:
    - match: '{{int}}'
      scope: constant.numeric.jlf
      set: rangeTailOptinal
    - match: '{{beginOfExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set: [rangeTailOptinal, exprEnd, expr]
    - include: stringInclude
    - match: '{{any}}'
      pop: true

  iteratorEnd:
    - meta_include_prototype: false
    - match: '{{endOfIterator}}'
      scope: punctuation.section.bracket.begin.jlf
      set:
        - meta_include_prototype: false
        - match: '{{beginOfIterator}}'
          scope: punctuation.section.bracket.begin.jlf
          set: [iteratorEnd, iteratorConditionOptional, iteratorNegationOptional]
        - match: '{{any}}'
          set: genValue
    - include: illegalInclude

# =============================================================================

  varSpecChainInclude:
    - meta_include_prototype: false
    - match: '(?={{varStarter}})'
      set: [chainNextSegmentOptional, varSpec]

  varSpecChain:
    - include: varSpecChainInclude
    - include: illegalInclude

  chainNextSegmentOptional:
    - meta_include_prototype: false
    - match: '{{pathSegmentSeparator}}'
      scope: keyword.jlf
      push: chainSegmentSpec
    - match: '{{optionalEnder}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  varSpec:
    - meta_include_prototype: false
    - include: varSpecInclude

  chainSegmentSpec:
    - match: '(?={{defStarter}})'
      set: [chainNextSegmentOptional, defWithStarter]
    - match: '{{beginOfIterator}}'
      scope: punctuation.section.bracket.begin.jlf
      set: [chainNextSegmentOptional, iteratorEnd, iteratorConditionOptional, iteratorNegationOptional]
    - include: intInclude
    - include: exprInclude
    - include: varSpecInclude
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - include: quotedInclude
    - match: '{{chainSegmentSpecStarter}}'
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - include: nonQuotedStringTailInclude
    - include: illegalInclude

# =============================================================================

  varSpecInclude:
    - meta_include_prototype: false
    - match: '({{varStarter}})'
      scope: keyword.jlf
      set: [varArgsOptional, varName]

  varChainInclude:
    - meta_include_prototype: false
    - match: '({{varStarter}})'
      scope: keyword.jlf
      set: [chainNextSegmentOptional, varArgsOptional, varName]

  varName:
    - meta_include_prototype: false
    - match: '(Key|Idx|Len|File|Ref|\.\.|\.)(?={{endOfNonQuotedString}})'
      scope: entity.name.label.jlf
      pop: true
    - match: '(?={{endOfNonQuotedString}})'
      set: illegalInclude
    - match: '{{any}}'
      set:
        - meta_include_prototype: false
        - clear_scopes: true
        - meta_scope: entity.name.variable.jlf
        - include: nonQuotedStringTailInclude

  varArgsOptional:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfMap}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [commaSeparatorOptional, value, keySeparatorOptional, argName]
    - include: arrayInclude
    - include: exprInclude
    - match: '{{any}}'
      pop: true

  specInclude:
    - meta_include_prototype: false
    - include: varSpecArgsInclude
    - include: nonQuotedStringTailInclude

# =============================================================================

  exprInclude:
    - meta_include_prototype: false
    - match: '{{beginOfExpr}}'
      scope: punctuation.section.parens.begin.jlf
      set:
        - match: '{{negationMark}}'
          set: [exprEnd, exprTernaryBeginOptional, boolExprTailOptional, valueChain]
        - match: '{{any}}'
          set: [exprEnd, exprTernaryBeginOptional, exprTailOptional, valueChain]

  negationMarkOptional:
    - meta_include_prototype: false
    - match: '{{negationMark}}'
      pop: true
    - match: '{{any}}'
      pop: true

  exprEnd:
    - match: '{{endOfExpr}}'
      scope: punctuation.section.parens.end.jlf
      pop: true
    - include: illegalInclude

  expr:
    - include: exprInclude
    - include: illegalInclude

  exprSumTailInclude:
    - match: '{{sumOps}}{{spaceAfter}}'
      set: [ exprSumTailOptional, valueChain ]

  exprSumTailOptional:
    - include: exprSumTailInclude
    - match: '{{any}}'
      pop: true

  exprMulTailInclude:
    - match: '{{mulOps}}{{spaceAfter}}'
      set: [ exprMulTailOptional, valueChain ]

  exprMulTailOptional:
    - include: exprMulTailInclude
    - match: '{{any}}'
      pop: true

  exprOrTailInclude:
    - match: '{{orOp}}{{spaceAfter}}'
      set: [ exprOrTailOptional, valueChain, negationMarkOptional]

  exprOrTailOptional:
    - include: exprOrTailInclude
    - match: '{{any}}'
      pop: true

  exprAndTailInclude:
    - match: '{{andOp}}{{spaceAfter}}'
      set: [ exprAndTailOptional, valueChain, negationMarkOptional]

  exprAndTailOptional:
    - include: exprAndTailInclude
    - match: '{{any}}'
      pop: true

  boolExprTailInclude:
    - include: exprOrTailInclude
    - include: exprAndTailInclude

  boolExprTailOptional:
    - include: boolExprTailInclude
    - match: '{{any}}'
      pop: true

  exprTailOptional:
    - include: exprSumTailInclude
    - include: exprMulTailInclude
    - match: '{{cmpOps}}{{spaceAfter}}'
      scope: keyword.operator.logical.jlf
      set: [valueChain]
    - match: '{{defMatchOp}}{{spaceAfter}}'
      scope: keyword.operator.logical.jlf
      set: [defValue]
    - include: boolExprTailInclude
    - match: '{{any}}'
      pop: true

  exprTernaryBeginOptional:
    - match: '{{ternaryIf}}{{ternaryDelimiter}}'
      scope: keyword.jlf
      push: valueWithoutTernary
    - match: '{{ternaryIf}}'
      scope: keyword.jlf
      push: [valueWithoutTernary, exprTernaryDelimiter, valueWithoutTernary]
    - match: '{{any}}'
      pop: true

  exprTernaryIf:
    - match: '{{ternaryIf}}'
      scope: keyword.jlf
      pop: true
    - include: illegalInclude

  exprTernaryDelimiter:
    - match: '{{ternaryDelimiter}}'
      pop: true
    - include: illegalInclude

# =============================================================================

  intInclude:
    - match: '{{int}}'
      scope: constant.numeric.jlf
      pop: true

# =============================================================================

  escapeInclude:
    - meta_include_prototype: false
    - match: '(?=\\$)'
      set:
        - include: illegalInclude
    - match: '\\{{escapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '\\"'
      scope: constant.character.escape.jlf
      push:
        - match: '"'
          scope: constant.character.escape.jlf
          pop: true
    - match: '(\\).'
      captures:
        1: comment.jlf

  nonQuotedStringTailInclude:
    - meta_include_prototype: false
    - match: '{{escapeStarter}}(?={{beginOfExpr}})'
      scope: keyword.jlf
      push: expr
    - match: '(?={{endOfNonQuotedString}})'
      pop: true
    - match: '({{escapeStarter}}){{endOfNonQuotedString}}'
      captures:
        1: constant.character.escape.jlf
    - include: escapeInclude

  quotedInclude:
    - meta_include_prototype: false
    - match: '{{escapeStarter}}u'
      push:
        - meta_scope: constant.character.escape.jlf
        - match: '[0-9a-fA-F]{4}'
          pop: true
        - include: illegalInclude
    - match: '{{escapeStarter}}{{jsonQuotedEscapeRunes}}'
      scope: constant.character.escape.jlf
    - match: '({{escapeStarter}})({{jsonQuotedEscapeRunesAsIs}})'
      captures:
        1: constant.character.escape.jlf
    - match: '({{escapeStarter}})([{{doubleQuotedValidRune}}])'
      captures:
        1: comment.jlf
    - match: '(?={{escapeStarter}}|[^{{doubleQuotedValidRune}}])'
      set:
        - include: illegalInclude
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.end.jlf
      pop: true

  quotedStringInclude:
    - meta_include_prototype: false
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.jlf
        - match: '{{escapeStarter}}(?={{beginOfExpr}})'
          scope: keyword.jlf
          push: expr
        - include: quotedInclude

# =============================================================================

  valueChainStart:
    - include: varSpecInclude
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: rangeTailOptinal
    - match: '(?={{beginOfExpr}})'
      set: [rangeTailOptinal, expr]
    - include: mapInclude
    - include: defInclude
    - include: genInclude
    - include: arrayInclude
    - include: boolInclude
    - include: nilInclude
    - include: stringInclude
    - include: illegalInclude

  valueChain:
    - match: '{{any}}'
      set: [chainNextSegmentOptional, valueChainStart]

  valueWithoutTernary:
    - match: '{{negationMark}}'
      set: [boolExprTailOptional, valueChain]
    - match: '{{any}}'
      set: [exprTailOptional, valueChain]

  value:
    - include: varChainInclude
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: rangeTailOptinal
    - match: '(?={{beginOfExpr}})'
      set: [rangeTailOptinal, expr]
    - include: mapInclude
    - include: defInclude
    - include: genInclude
    - include: arrayInclude
    - include: boolInclude
    - include: nilInclude
    - include: stringInclude

# =====================================

  stringInclude:
    - meta_include_prototype: false
    - include: quotedStringInclude
    - match: '{{beginOfNonQuotedString}}'
      set:
        - meta_include_prototype: false
        - meta_scope: string.jlf
        - include: nonQuotedStringTailInclude

  stringValue:
    - include: commonValueInclude
    - include: stringInclude
    - include: illegalInclude

# =====================================

  mapInclude:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfMap}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '(?={{varStarter}})'
          push: [commaSeparatorOptional, optionalSpreadOptional, varSpec]
        - match: '(?={{beginOfExpr}})'
          push: [commaSeparatorOptional, optionalSpreadOptional, expr]
        - match: '{{any}}'
          push: [commaSeparatorOptional, value, keySeparatorOptional, optionalEnderOptional, key]

  spreadOptional:
    - meta_include_prototype: false
    - match: '\.\.\.'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  optionalSpreadOptional:
    - meta_include_prototype: false
    - match: '\.\.\.'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  key:
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - include: quotedInclude
    - match: '{{beginOfNonQuotedKey}}'
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '(?={{endOfNonQuotedKey}})'
          pop: true
        - match: '(\\){{endOfNonQuotedKey}}'
          captures:
            1: constant.character.escape.jlf
        - include: escapeInclude
    - include: illegalInclude

  keySeparatorOptional:
    - meta_include_prototype: false
    - match: '{{keySeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  commaSeparatorOptional:
    - match: '{{commaSeparatorOptional}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =====================================

  arrayInclude:
    - meta_include_prototype: false
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfArray}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [arrayIncludeHelper]

  arrayIncludeHelper:
    - match: '(?={{varStarter}})'
      push: [spreadOptional, varSpec]
    - match: '{{any}}'
      push: [value]

# =====================================

  boolInclude:
    - meta_include_prototype: false
    - match: \b{{bool}}\b
      scope: constant.language.jlf
      pop: true

# =====================================

  nilInclude:
    - meta_include_prototype: false
    - match: \b{{nil}}\b
      scope: constant.language.jlf
      pop: true

# =============================================================================

  rangeValue:
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set:
        - meta_include_prototype: false
        - match: '{{rangeSeparator}}'
          scope: keyword.jlf
          set: numberValue
        - include: illegalInclude
    - match: '(?={{varStarter}})'
      set: [rangeTailOptinal, varSpecChain]
    - match: '(?={{beginOfExpr}})'
      set: [rangeTailOptinal, expr]
    - include: illegalInclude

  rangeTailOptinal:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      scope: keyword.jlf
      set: numberValue
    - match: '{{any}}'
      pop: true

# =============================================================================

  numberValue:
    - include: commonValueInclude
    - include: numberInclude
    - include: illegalInclude

  numberInclude:
    - match: '{{number}}'
      scope: constant.numeric.jlf
      pop: true

# =============================================================================

  commonValueInclude:
    - meta_include_prototype: false
    - include: varSpecChainInclude
    - include: exprInclude

# =============================================================================

  stringsValue:
    - include: commonValueInclude
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfArray}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [ commaSeparatorOptional, stringsValue ]
    - include: stringInclude
    - include: illegalInclude

# =============================================================================

  defValue:
    - include: commonValueInclude
    - match: '{{any}}'
      set: [def, defStarterOptional]

  defStarterOptional:
    - match: '{{defStarter}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  defInclude:
    - meta_include_prototype: false
    - match: '{{defStarter}}'
      scope: keyword.jlf
      set: def

  defWithStarter:
    - match: '(?={{defStarter}})'
      set:
        - include: defInclude
    - include: illegalInclude

  def:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: keyOfDef
    - match: '{{any}}'
      set: defType

  keyOfDef:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, defType, keySeparatorOptional]
    - match: \bkeysDef\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, defKeysDefValue, keySeparatorOptional]
    - match: \b(enum|keys)\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, stringsValue, keySeparatorOptional]
    - match: \b(elemDef|arrayElemDef)\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, defValue, keySeparatorOptional]
    - match: \brange\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, rangeValue, keySeparatorOptional]
    - match: \bisOptional\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, boolValue, keySeparatorOptional]
    - match: \bdefault\b
      scope: keyword.jlf
      push: [commaSeparatorOptional, value, keySeparatorOptional]
    - include: illegalInclude

  defType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfArray}}'
          pop: true
        - match: \b{{defTypeMulti}}|{{defTypeSingle}}\b
          scope: variable.parameter
        - include: illegalInclude
    - include: illegalInclude

# =============================================================================

  defKeysDefValueInclude:
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - match: '{{endOfMap}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: '{{any}}'
          push: [ defValue, keySeparatorOptional, optionalEnderOptional, key]

  defKeysDefValue:
    - include: commonValueInclude
    - include: defKeysDefValueInclude
    - include: illegalInclude

# =============================================================================

  optionalEnderOptional:
    - meta_include_prototype: false
    - match: '{{optionalEnder}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =============================================================================

  boolValue:
    - include: commonValueInclude
    - include: boolInclude
    - include: illegalInclude

# =============================================================================

%YAML 1.2
---
name: JLF
# See http://www.sublimetext.com/docs/3/syntax.html
file_extensions:
  - jlf
scope: source.jlf

variables:
  space: '[\s]+'
  beginOfSingleLineComment: '//'
  beginOfMultiLineComment: '/\*'
  endOfMultiLineComment: '\*/'

  number: '[\+\-]?\d+(?:\.\d+)?'
  id: '[a-zA-Z_\./~]([a-zA-Z_\./\-~\d]*)'
  bool: true|false
  nil: nil

  beginOfMap: '\{'
  keySeparator: '(:|=>)'
  valueSeparator: ','
  endOfMap: '\}'

  beginOfArray: '\['
  endOfArray: '\]'

  beginOfArrayString: '\<'
  endOfArrayString: '\>'
  arrayOfString: '{{beginOfArrayString}}([^{{endOfArrayString}}]*){{endOfArrayString}}'

  any: '(?=.)'

  doubleQuotedStringDelimiter: '"'
  singleQuotedStringDelimiter: "'"
  doubleEscapeRunes: "abfnrtv"
  singleEscapeRunes: "\\\\\"'"

  escapeStarter: '\\'
  varStarter: '\$'
  funcStarter: '\&'
  fileSpecStarter: '%'
  defStarter: '\^'
  pathStarter: '\*'

  beginOfPath: '\('
  endOfPath: '\)'
  int: '[-+]?\d+'

  pathSegmentSeparator: ':'
  rangeSeparator: '\.\.'
  assignSeparator: '(=>|:?=|:)'

  defTypeSingle: 'Array|Map|String|Int|Number|Bool'
  defTypeMulti: 'ArrayOf'

  pathUpperLevel: '\.\.'
  pathCurrLevel: '\.'
  pathOptionalSign: '\?'
  newline: '\n'

# =============================================================================
# =============================================================================

contexts:

  prototype:
    - include: space

  space:
    - meta_include_prototype: false
    - match: '{{space}}'
    - match: '{{beginOfSingleLineComment}}'
      scope: punctuation.definition.comment.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment.line.jlf
        - match: $
          pop: true
    - match: '{{beginOfMultiLineComment}}'
      scope: punctuation.definition.comment.begin.jlf
      push:
        - meta_include_prototype: false
        - meta_scope: comment
        - match: '{{endOfMultiLineComment}}'
          scope: punctuation.definition.comment.end.jlf
          pop: true

  illegal:
    - meta_include_prototype: false
    - match: .
      scope: invalid.illegal.jlf

# =============================================================================

  main:
    - match: '({{varStarter}})({{defStarter}})'
      captures:
        1: keyword.jlf
        2: keyword.jlf
      set: [main, defOrPath, assignSeparator]
    - match: '{{varStarter}}'
      scope: keyword.jlf
      set: [main, expr, assignSeparator, var]
    - match: '{{any}}'
      set: [end, value]

  end:
    - match: '({{varStarter}})({{defStarter}})'
      captures:
        1: keyword.jlf
        2: keyword.jlf
      set: [end, defOrPath, assignSeparator]
    - match: '{{varStarter}}'
      scope: keyword.jlf
      set: [end, expr, assignSeparator, var]
    - include: illegal

  assignSeparator:
    - match: '{{assignSeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =============================================================================

  expr:
    # - match: '{{fileSpecStarter}}'
    #   scope: keyword.jlf
    #   set: [ exprTail, pathTail, fileSpec ]
    # - match: '{{varStarter}}'
    #   scope: keyword.jlf
    #   set: [ exprTail, pathTail, var ]
    # - include: subExpr
    # - include: value
    - match: '{{any}}'
      set: [exprTail, pathTail, value]

  exprTail:
    - match: '\+|\-'
      set: [exprTail, expr]
   # - include: subExpr
    - match: '{{any}}'
      pop: true

  subExpr:
    - meta_include_prototype: false
    - match: '\('
      set: [subExprEnd, expr]

  subExprEnd:
    - match: '\)'
      pop: true

# =============================================================================

  fileSpec:
    - meta_include_prototype: false
    # - include: subExpr
    - match: '\('
      set: [fileSpec, subExprEnd, expr]
    - match: '{{id}}'
      scope: meta.path.jlf
    - match: '{{any}}'
      pop: true

  pathTail:
    - match: '\|'
      set: [ pathTail, pathSegment ]
    - match: '{{any}}'
      pop: true

  pathSegment:
    - match: '{{id}}'
      scope: support.function.jlf
      pop: true

# =============================================================================

  varValue:
    - meta_include_prototype: false
    - match: '{{fileSpecStarter}}'
      scope: keyword.jlf
      set: fileSpec
    - match: '{{varStarter}}'
      scope: keyword.jlf
      set: var
    - match: '{{pathStarter}}'
      scope: keyword.jlf
      set: pathSegment

  value:
    - include: varValue
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: mayBeRange
    # - match: '{{beginOfPath}}'
    #   scope: punctuation.section.block.begin.jlf
    #   set: [ mayBeRange, endOfPathSegment, pathBeginSegment ]
    # - include: path
    - include: map
    - include: def
    - include: array
    - include: arrayOfString
    - include: bool
    - include: nil
    - include: string
    - include: illegal

  mayBeRange:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      set: rangeMaxValue
    - match: '{{any}}'
      pop: true

# =====================================

  nonBoolNil:
    - meta_include_prototype: false
    - match: \b{{bool}}|{{nil}}\b
      scope: invalid.illegal.jlf
      pop: true

  string:
    - meta_include_prototype: false
    - include: quotedString
    - include: nonBoolNil
    - match: \b{{id}}\b
      scope: string.quoted.double.jlf
      pop: true

  quotedString:
    - meta_include_prototype: false
    - match: '{{singleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{singleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true

# =====================================

  map:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: mapTail

  mapTail:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ mapTail, valueSeparator, value, keySeparator, key ]

  key:
    - match: '{{singleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{singleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: \b{{id}}\b
      scope: support.function.jlf
      pop: true
    - include: illegal

  keySeparator:
    - match: '{{keySeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  valueSeparator:
    - match: '{{valueSeparator}}'
      scope: comment.jlf
      pop: true
    - match: '{{any}}'
      pop: true

# =====================================

  def:
    - meta_include_prototype: false
    - match: '{{defStarter}}'
      scope: keyword.jlf
      set: defBegin

# =====================================

  array:
    - meta_include_prototype: false
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set: arrayTail

  arrayTail:
    - match: '{{endOfArray}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ arrayTail, valueSeparator, value]

# =====================================

  arrayOfString:
    - meta_include_prototype: false
    - match: '{{beginOfArrayString}}'
      scope: punctuation.section.block.begin.jlf
      set:
        - meta_include_prototype: false
        - match: '{{endOfArrayString}}'
          scope: punctuation.section.block.end.jlf
          pop: true
        - match: .
          scope: string.quoted.double.jlf

# =====================================

  bool:
    - meta_include_prototype: false
    - match: \b{{bool}}\b
      scope: constant.language.jlf
      pop: true

# =====================================

  nil:
    - meta_include_prototype: false
    - match: \b{{nil}}\b
      scope: constant.language.jlf
      pop: true

# =============================================================================

  rangeValue:
    - match: '{{number}}'
      scope: constant.numeric.jlf
      set: [ rangeMaxValue, rangeSeparator ]
    - match: '{{beginOfPath}}'
      set: [ rangeMaxValue, rangeSeparator, endOfPathSegment, pathBeginSegment ]
    - include: illegal

  rangeSeparator:
    - meta_include_prototype: false
    - match: '{{rangeSeparator}}'
      pop: true
    - include: illegal

  rangeMaxValue:
    - meta_include_prototype: false
    - match: '{{number}}'
      scope: constant.numeric.jlf
      pop: true
    - include: subExpr
    # - include: path
    - include: illegal

# =============================================================================

  strings:
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set: stringsTail
    - include: stringsItem
    - include: illegal

  stringsTail:
    - match: '{{endOfArray}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ stringsTail, valueSeparator, stringsItem]

  stringsItem:
    - include: string
    - include: arrayOfString
    - include: path
    - include: illegal

# =============================================================================

  # path:
  #   - meta_include_prototype: false
  #   - match: '{{fileSpecStarter}}'
  #     scope: keyword.jlf
  #     set: [ pathTail, pathFileSpec ]
  #   - match: '{{varStarter}}'
  #     scope: keyword.jlf
  #     set: [ pathTail, pathVar ]
  #   - match: '{{pathStarter}}'
  #     scope: keyword.jlf
  #     set:
  #       - meta_include_prototype: false
  #       - match: '{{id}}'
  #         scope: support.function.jlf
  #         set:

  # pathSegment:


      # set: [ pathTail, pathVar ]
    # - match: '{{pathCurrLevel}}(?={{pathSegmentSeparator}})'
    #   scope: meta.path
    #   pop: true

  # pathVar:

  pathFileSpec:
    - meta_include_prototype: false
    - include: subExpr
    - match: '{{id}}'
      scope: meta.path.jlf
    - match: '{{singleQuotedStringDelimiter}}'
      scope: keyword.jlf
      push:
        - meta_include_prototype: false
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{singleQuotedStringDelimiter}}'
          scope: keyword.jlf
          pop: true
        - match: .
          scope: meta.path
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: keyword.jlf
      push:
        - meta_include_prototype: false
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: keyword.jlf
          pop: true
        - match: .
          scope: meta.path
    - match: '{{escapeStarter}}'
      scope: constant.character.escape.jlf
      push:
        - meta_include_prototype: false
        - meta_include_prototype: false
        - match: '[\s]'
          scope: constant.character.escape.jlf
          pop: true
        - include: illegal
    - match: .
      scope: meta.path
    - include: illegal
    - match: '{{any}}'
      pop: true


    # - match: '{{beginOfPath}}'
    #   scope: punctuation.section.parens.begin.jlf
    #   set: [endOfPathSegment, pathBeginSegment]

  pathBeginSegment:
    - include: pathBeginOnlySegment
    - include: pathCommonSegment
    - include: illegal

  pathBeginOnlySegment:
    - meta_include_prototype: false
    - match: '{{fileSpecStarter}}'
      scope: keyword.jlf
      set: pathFileSpec
    - match: '{{pathCurrLevel}}(?={{pathSegmentSeparator}})'
      scope: meta.path
      pop: true

  pathCommonSegment:
    - meta_include_prototype: false
    - match: '{{varStarter}}'
      scope: keyword.jlf
      set: var
    - match: '{{funcStarter}}'
      scope: keyword.jlf
      set: [ pathFuncArg, pathFuncName ]
    - match: '{{int}}'
      scope: meta.path
      pop: true
    - match: '{{pathUpperLevel}}(?={{pathSegmentSeparator}})'
      scope: meta.path
      pop: true
    - match: '{{id}}'
      scope: support.function.jlf
      pop: true
    - match: '{{singleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{singleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: support.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true

  # pathSegment:
  #   - include: path
  #   - include: pathCommonSegment
  #   - include: illegal

  endOfPath:
    - meta_include_prototype: false
    - match: '{{endOfPath}}'
      scope: punctuation.section.parens.end.jlf
      pop: true

  endOfPathSegment:
    - match: '{{pathOptionalSign}}'
      scope: keyword.jlf
      set: pathOptionalSign
    - match: '{{any}}'
      set: nextPathSegment

  pathOptionalSign:
    - match: '(?=({{pathSegmentSeparator}}|{{endOfPath}}))'
      set: nextPathSegment
    - match: '{{any}}'
      set: [nextPathSegment, value]

  nextPathSegment:
    - include: endOfPath
    - match: '{{pathSegmentSeparator}}'
      scope: keyword.jlf
      set: nextPathSegmentHelper
    - include: illegal

  nextPathSegmentHelper:
    - match: '({{defStarter}})'
      scope: keyword.jlf
      set: [ pathEnd, defBegin]
    - match: '{{beginOfPath}}'
      scope: punctuation.section.block.begin.jlf
      set: [ pathEnd, endOfPathSegment, pathBeginSegment, ]
    - match: '{{any}}'
      set: [ endOfPathSegment, pathSegment]

  pathFuncName:
    - meta_include_prototype: false
    - match: \b{{id}}\b
      scope: entity.function.jlf
      pop: true
    - match: '{{singleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: entity.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{singleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: entity.function.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - include: illegal

  pathFuncArg:
    - match: '(?=({{pathSegmentSeparator}}|{{endOfPath}}))'
      pop: true
    - match: '{{any}}'
      set: value

  pathEnd:
    - include: endOfPath
    - include: illegal

  var:
    - meta_include_prototype: false
    - match: '{{id}}'
      scope: entity.name.jlf
      pop: true
    - match: '{{singleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: entity.name.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{singleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - match: '{{doubleQuotedStringDelimiter}}'
      scope: punctuation.definition.string.begin.jlf
      set:
        - meta_include_prototype: false
        - meta_scope: entity.name.jlf
        - match: '{{escapeStarter}}'
          scope: constant.character.escape.jlf
          push:
            - meta_include_prototype: false
            - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
              scope: constant.character.escape.jlf
              pop: true
            - include: illegal
        - match: '{{doubleQuotedStringDelimiter}}'
          scope: punctuation.definition.string.end.jlf
          pop: true
    - include: illegal

  # pathFileSpec:
  #   - meta_include_prototype: false
  #   - match: '(?={{pathSegmentSeparator}}|{{endOfPath}}|{{pathOptionalSign}}|{{newline}})'
  #     pop: true
  #   - match: '{{beginOfPath}}'
  #     scope: punctuation.section.parens.begin.jlf
  #     set: [ pathFileSpec, endOfPathSegment, pathBeginSegment]
  #   - match: '{{singleQuotedStringDelimiter}}'
  #     scope: keyword.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - match: '{{escapeStarter}}'
  #         scope: constant.character.escape.jlf
  #         push:
  #           - meta_include_prototype: false
  #           - match: "[{{singleEscapeRunes}}]"
  #             scope: constant.character.escape.jlf
  #             pop: true
  #           - include: illegal
  #       - match: '{{singleQuotedStringDelimiter}}'
  #         scope: keyword.jlf
  #         pop: true
  #       - match: .
  #         scope: meta.path
  #   - match: '{{doubleQuotedStringDelimiter}}'
  #     scope: keyword.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - match: '{{escapeStarter}}'
  #         scope: constant.character.escape.jlf
  #         push:
  #           - meta_include_prototype: false
  #           - match: "[{{singleEscapeRunes}}{{doubleEscapeRunes}}]"
  #             scope: constant.character.escape.jlf
  #             pop: true
  #           - include: illegal
  #       - match: '{{doubleQuotedStringDelimiter}}'
  #         scope: keyword.jlf
  #         pop: true
  #       - match: .
  #         scope: meta.path
  #   - match: '{{escapeStarter}}'
  #     scope: constant.character.escape.jlf
  #     push:
  #       - meta_include_prototype: false
  #       - meta_include_prototype: false
  #       - match: '[\s]'
  #         scope: constant.character.escape.jlf
  #         pop: true
  #       - include: illegal
  #   - match: .
  #     scope: meta.path
  #   - include: illegal

# =============================================================================

  defBegin:
    - meta_include_prototype: false
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: keyOfDef
    - include: defType
    - include: illegal

  defOrPath:
    - include: path
    - include: varValue
    # - include: defBegin

  keyOfDef:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: \btype\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, defType, keySeparator]
    - match: \benum\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, strings, keySeparator]
    - match: \bkeysDef\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, defKeysDef, keySeparator]
    - match: \bkeys\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, strings, keySeparator]
    - match: \b(elemDef|arrayElemDef)\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, defOrPath, keySeparator]
    - match: \brange\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, rangeValue, keySeparator]
    - match: \bisOptional\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, boolValue, keySeparator]
    - match: \bdefault\b
      scope: keyword.jlf
      set: [keyOfDef, valueSeparator, value, keySeparator]
    - include: illegal

  defType:
    - match: \b{{defTypeSingle}}\b
      scope: variable.parameter
      pop: true
    - match: '{{beginOfArrayString}}'
      scope: punctuation.section.block.begin.jlf
      set: defTypeAsArrayOfString
    - match: '{{beginOfArray}}'
      scope: punctuation.section.block.begin.jlf
      set: defTypeAsArray
    - include: illegal

  defTypeAsArray:
    - match: '{{endOfArray}}'
      pop: true
    - include: defTypeAsArrayItem
    - include: illegal

  defTypeAsArrayOfString:
    - include: defTypeAsArrayItem
    - match: '{{endOfArrayString}}'
      pop: true
    - include: illegal

  defTypeAsArrayItem:
    - meta_include_prototype: false
    - match: \b{{defTypeMulti}}|{{defTypeSingle}}\b
      scope: variable.parameter

  defKeysDef:
    - match: '{{beginOfMap}}'
      scope: punctuation.section.block.begin.jlf
      set: defKeysTail
    - include: illegal

  defKeysTail:
    - match: '{{endOfMap}}'
      scope: punctuation.section.block.end.jlf
      pop: true
    - match: '{{any}}'
      set: [ defKeysTail, defOrPath, keySeparator, optionalSign, keyOfDefKeys]

  keyOfDefKeys:
    - include: key
    - include: illegal

  optionalSign:
    - meta_include_prototype: false
    - match: '{{pathOptionalSign}}'
      scope: keyword.jlf
      pop: true
    - match: '{{any}}'
      pop: true

  boolValue:
    - include: bool
    - include: illegal

# =============================================================================

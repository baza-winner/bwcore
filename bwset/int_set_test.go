// Code generated by "bwsetter -type=int"; DO NOT EDIT; bwsetter: go get -type=int -set=Int -test%!(EXTRA string=github.com/baza-winner/bwcore/bwsetter)

package bwset

import (
	"encoding/json"
	bwtesting "github.com/baza-winner/bwcore/bwtesting"
	"strconv"
	"testing"
)

func TestInt(t *testing.T) {
	bwtesting.BwRunTests(t, IntFrom, map[string]bwtesting.Case{"IntFrom": {
		In: []interface{}{_IntTestItemA, _IntTestItemB},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, IntFromSlice, map[string]bwtesting.Case{"IntFromSlice": {
		In: []interface{}{[]int{_IntTestItemA, _IntTestItemB}},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, IntFromSet, map[string]bwtesting.Case{"IntFromSet": {
		In: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Int.Copy, map[string]bwtesting.Case{"Int.Copy": {
		In: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Int.ToSlice, map[string]bwtesting.Case{"Int.ToSlice": {
		In:  []interface{}{Int{_IntTestItemA: struct{}{}}},
		Out: []interface{}{[]int{_IntTestItemA}},
	}})
	bwtesting.BwRunTests(t, _IntToSliceTestHelper, map[string]bwtesting.Case{"_IntToSliceTestHelper": {
		In:  []interface{}{[]int{_IntTestItemB, _IntTestItemA}},
		Out: []interface{}{[]int{_IntTestItemA, _IntTestItemB}},
	}})
	bwtesting.BwRunTests(t, Int.String, map[string]bwtesting.Case{"Int.String": {
		In: []interface{}{Int{_IntTestItemA: struct{}{}}},
		Out: []interface{}{func() string {
			result, _ := json.Marshal(_IntTestItemA)
			return "[" + string(result) + "]"
		}()},
	}})
	bwtesting.BwRunTests(t, Int.MarshalJSON, map[string]bwtesting.Case{"Int.MarshalJSON": {
		In: []interface{}{Int{_IntTestItemA: struct{}{}}},
		Out: []interface{}{(func() []byte {
			result, _ := json.Marshal([]interface{}{_IntTestItemA})
			return result
		})(), nil},
	}})
	bwtesting.BwRunTests(t, Int.ToSliceOfStrings, map[string]bwtesting.Case{"Int.ToSliceOfStrings": {
		In:  []interface{}{Int{_IntTestItemA: struct{}{}}},
		Out: []interface{}{[]string{strconv.FormatInt(int64(_IntTestItemA), 10)}},
	}})
	bwtesting.BwRunTests(t, Int.Has, map[string]bwtesting.Case{
		"Int.Has: false": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, _IntTestItemB},
			Out: []interface{}{false},
		},
		"Int.Has: true": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, _IntTestItemA},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Int.HasAny, map[string]bwtesting.Case{
		"Int.HasAny: empty": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}},
			Out: []interface{}{false},
		},
		"Int.HasAny: false": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, _IntTestItemB},
			Out: []interface{}{false},
		},
		"Int.HasAny: true": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, _IntTestItemA, _IntTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Int.HasAnyOfSlice, map[string]bwtesting.Case{
		"Int.HasAnyOfSlice: empty": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, []int{}},
			Out: []interface{}{false},
		},
		"Int.HasAnyOfSlice: false": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, []int{_IntTestItemB}},
			Out: []interface{}{false},
		},
		"Int.HasAnyOfSlice: true": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, []int{_IntTestItemA, _IntTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Int.HasAnyOfSet, map[string]bwtesting.Case{
		"Int.HasAnyOfSet: empty": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, Int{}},
			Out: []interface{}{false},
		},
		"Int.HasAnyOfSet: false": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, Int{_IntTestItemB: struct{}{}}},
			Out: []interface{}{false},
		},
		"Int.HasAnyOfSet: true": {
			In: []interface{}{Int{_IntTestItemA: struct{}{}}, Int{
				_IntTestItemA: struct{}{},
				_IntTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Int.HasEach, map[string]bwtesting.Case{
		"Int.HasEach: empty": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}},
			Out: []interface{}{true},
		},
		"Int.HasEach: false": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, _IntTestItemA, _IntTestItemB},
			Out: []interface{}{false},
		},
		"Int.HasEach: true": {
			In: []interface{}{Int{
				_IntTestItemA: struct{}{},
				_IntTestItemB: struct{}{},
			}, _IntTestItemA, _IntTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Int.HasEachOfSlice, map[string]bwtesting.Case{
		"Int.HasEachOfSlice: empty": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, []int{}},
			Out: []interface{}{true},
		},
		"Int.HasEachOfSlice: false": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, []int{_IntTestItemA, _IntTestItemB}},
			Out: []interface{}{false},
		},
		"Int.HasEachOfSlice: true": {
			In: []interface{}{Int{
				_IntTestItemA: struct{}{},
				_IntTestItemB: struct{}{},
			}, []int{_IntTestItemA, _IntTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Int.HasEachOfSet, map[string]bwtesting.Case{
		"Int.HasEachOfSet: empty": {
			In:  []interface{}{Int{_IntTestItemA: struct{}{}}, Int{}},
			Out: []interface{}{true},
		},
		"Int.HasEachOfSet: false": {
			In: []interface{}{Int{_IntTestItemA: struct{}{}}, Int{
				_IntTestItemA: struct{}{},
				_IntTestItemB: struct{}{},
			}},
			Out: []interface{}{false},
		},
		"Int.HasEachOfSet: true": {
			In: []interface{}{Int{
				_IntTestItemA: struct{}{},
				_IntTestItemB: struct{}{},
			}, Int{
				_IntTestItemA: struct{}{},
				_IntTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Int._AddTestHelper, map[string]bwtesting.Case{"Int.Add": {
		In: []interface{}{Int{_IntTestItemA: struct{}{}}, _IntTestItemB},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Int._AddSliceTestHelper, map[string]bwtesting.Case{"Int.AddSlice": {
		In: []interface{}{Int{_IntTestItemA: struct{}{}}, []int{_IntTestItemB}},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Int._AddSetTestHelper, map[string]bwtesting.Case{"Int.AddSet": {
		In: []interface{}{Int{_IntTestItemA: struct{}{}}, Int{_IntTestItemB: struct{}{}}},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Int._DelTestHelper, map[string]bwtesting.Case{"Int.Del": {
		In: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}, _IntTestItemB},
		Out: []interface{}{Int{_IntTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Int._DelSliceTestHelper, map[string]bwtesting.Case{"Int.DelSlice": {
		In: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}, []int{_IntTestItemB}},
		Out: []interface{}{Int{_IntTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Int._DelSetTestHelper, map[string]bwtesting.Case{"Int.DelSet": {
		In: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}, Int{_IntTestItemB: struct{}{}}},
		Out: []interface{}{Int{_IntTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Int.Union, map[string]bwtesting.Case{"Int.Union": {
		In: []interface{}{Int{_IntTestItemA: struct{}{}}, Int{_IntTestItemB: struct{}{}}},
		Out: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Int.Intersect, map[string]bwtesting.Case{"Int.Intersect": {
		In: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}, Int{_IntTestItemB: struct{}{}}},
		Out: []interface{}{Int{_IntTestItemB: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Int.Subtract, map[string]bwtesting.Case{"Int.Subtract": {
		In: []interface{}{Int{
			_IntTestItemA: struct{}{},
			_IntTestItemB: struct{}{},
		}, Int{_IntTestItemB: struct{}{}}},
		Out: []interface{}{Int{_IntTestItemA: struct{}{}}},
	}})
}

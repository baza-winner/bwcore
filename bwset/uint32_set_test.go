// Code generated by "bwsetter -type=uint32"; DO NOT EDIT; bwsetter: go get -type=uint32 -set=Uint32 -test%!(EXTRA string=github.com/baza-winner/bwcore/bwsetter)

package bwset

import (
	"encoding/json"
	bwtesting "github.com/baza-winner/bwcore/bwtesting"
	"strconv"
	"testing"
)

func TestUint32(t *testing.T) {
	bwtesting.BwRunTests(t, Uint32From, map[string]bwtesting.Case{"Uint32From": {
		In: []interface{}{_Uint32TestItemA, _Uint32TestItemB},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32FromSlice, map[string]bwtesting.Case{"Uint32FromSlice": {
		In: []interface{}{[]uint32{_Uint32TestItemA, _Uint32TestItemB}},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32FromSet, map[string]bwtesting.Case{"Uint32FromSet": {
		In: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32.Copy, map[string]bwtesting.Case{"Uint32.Copy": {
		In: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32.ToSlice, map[string]bwtesting.Case{"Uint32.ToSlice": {
		In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
		Out: []interface{}{[]uint32{_Uint32TestItemA}},
	}})
	bwtesting.BwRunTests(t, _Uint32ToSliceTestHelper, map[string]bwtesting.Case{"_Uint32ToSliceTestHelper": {
		In:  []interface{}{[]uint32{_Uint32TestItemB, _Uint32TestItemA}},
		Out: []interface{}{[]uint32{_Uint32TestItemA, _Uint32TestItemB}},
	}})
	bwtesting.BwRunTests(t, Uint32.String, map[string]bwtesting.Case{"Uint32.String": {
		In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
		Out: []interface{}{func() string {
			result, _ := json.Marshal(_Uint32TestItemA)
			return "[" + string(result) + "]"
		}()},
	}})
	bwtesting.BwRunTests(t, Uint32.MarshalJSON, map[string]bwtesting.Case{"Uint32.MarshalJSON": {
		In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
		Out: []interface{}{(func() []byte {
			result, _ := json.Marshal([]interface{}{_Uint32TestItemA})
			return result
		})(), nil},
	}})
	bwtesting.BwRunTests(t, Uint32.ToSliceOfStrings, map[string]bwtesting.Case{"Uint32.ToSliceOfStrings": {
		In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
		Out: []interface{}{[]string{strconv.FormatUint(uint64(_Uint32TestItemA), 10)}},
	}})
	bwtesting.BwRunTests(t, Uint32.Has, map[string]bwtesting.Case{
		"Uint32.Has: false": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, _Uint32TestItemB},
			Out: []interface{}{false},
		},
		"Uint32.Has: true": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, _Uint32TestItemA},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Uint32.HasAny, map[string]bwtesting.Case{
		"Uint32.HasAny: empty": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
			Out: []interface{}{false},
		},
		"Uint32.HasAny: false": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, _Uint32TestItemB},
			Out: []interface{}{false},
		},
		"Uint32.HasAny: true": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, _Uint32TestItemA, _Uint32TestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Uint32.HasAnyOfSlice, map[string]bwtesting.Case{
		"Uint32.HasAnyOfSlice: empty": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, []uint32{}},
			Out: []interface{}{false},
		},
		"Uint32.HasAnyOfSlice: false": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, []uint32{_Uint32TestItemB}},
			Out: []interface{}{false},
		},
		"Uint32.HasAnyOfSlice: true": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, []uint32{_Uint32TestItemA, _Uint32TestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Uint32.HasAnyOfSet, map[string]bwtesting.Case{
		"Uint32.HasAnyOfSet: empty": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, Uint32{}},
			Out: []interface{}{false},
		},
		"Uint32.HasAnyOfSet: false": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, Uint32{_Uint32TestItemB: struct{}{}}},
			Out: []interface{}{false},
		},
		"Uint32.HasAnyOfSet: true": {
			In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, Uint32{
				_Uint32TestItemA: struct{}{},
				_Uint32TestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Uint32.HasEach, map[string]bwtesting.Case{
		"Uint32.HasEach: empty": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
			Out: []interface{}{true},
		},
		"Uint32.HasEach: false": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, _Uint32TestItemA, _Uint32TestItemB},
			Out: []interface{}{false},
		},
		"Uint32.HasEach: true": {
			In: []interface{}{Uint32{
				_Uint32TestItemA: struct{}{},
				_Uint32TestItemB: struct{}{},
			}, _Uint32TestItemA, _Uint32TestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Uint32.HasEachOfSlice, map[string]bwtesting.Case{
		"Uint32.HasEachOfSlice: empty": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, []uint32{}},
			Out: []interface{}{true},
		},
		"Uint32.HasEachOfSlice: false": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, []uint32{_Uint32TestItemA, _Uint32TestItemB}},
			Out: []interface{}{false},
		},
		"Uint32.HasEachOfSlice: true": {
			In: []interface{}{Uint32{
				_Uint32TestItemA: struct{}{},
				_Uint32TestItemB: struct{}{},
			}, []uint32{_Uint32TestItemA, _Uint32TestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Uint32.HasEachOfSet, map[string]bwtesting.Case{
		"Uint32.HasEachOfSet: empty": {
			In:  []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, Uint32{}},
			Out: []interface{}{true},
		},
		"Uint32.HasEachOfSet: false": {
			In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, Uint32{
				_Uint32TestItemA: struct{}{},
				_Uint32TestItemB: struct{}{},
			}},
			Out: []interface{}{false},
		},
		"Uint32.HasEachOfSet: true": {
			In: []interface{}{Uint32{
				_Uint32TestItemA: struct{}{},
				_Uint32TestItemB: struct{}{},
			}, Uint32{
				_Uint32TestItemA: struct{}{},
				_Uint32TestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Uint32._AddTestHelper, map[string]bwtesting.Case{"Uint32.Add": {
		In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, _Uint32TestItemB},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32._AddSliceTestHelper, map[string]bwtesting.Case{"Uint32.AddSlice": {
		In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, []uint32{_Uint32TestItemB}},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32._AddSetTestHelper, map[string]bwtesting.Case{"Uint32.AddSet": {
		In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, Uint32{_Uint32TestItemB: struct{}{}}},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32._DelTestHelper, map[string]bwtesting.Case{"Uint32.Del": {
		In: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}, _Uint32TestItemB},
		Out: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Uint32._DelSliceTestHelper, map[string]bwtesting.Case{"Uint32.DelSlice": {
		In: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}, []uint32{_Uint32TestItemB}},
		Out: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Uint32._DelSetTestHelper, map[string]bwtesting.Case{"Uint32.DelSet": {
		In: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}, Uint32{_Uint32TestItemB: struct{}{}}},
		Out: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Uint32.Union, map[string]bwtesting.Case{"Uint32.Union": {
		In: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}, Uint32{_Uint32TestItemB: struct{}{}}},
		Out: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Uint32.Intersect, map[string]bwtesting.Case{"Uint32.Intersect": {
		In: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}, Uint32{_Uint32TestItemB: struct{}{}}},
		Out: []interface{}{Uint32{_Uint32TestItemB: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Uint32.Subtract, map[string]bwtesting.Case{"Uint32.Subtract": {
		In: []interface{}{Uint32{
			_Uint32TestItemA: struct{}{},
			_Uint32TestItemB: struct{}{},
		}, Uint32{_Uint32TestItemB: struct{}{}}},
		Out: []interface{}{Uint32{_Uint32TestItemA: struct{}{}}},
	}})
}

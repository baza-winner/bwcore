// Code generated by "bwsetter -type=interface{}"; DO NOT EDIT; bwsetter: go get -type=interface{} -set=Interface -test -nosort%!(EXTRA string=github.com/baza-winner/bwcore/bwsetter)

package bwset

import (
	"encoding/json"
	bwjson "github.com/baza-winner/bwcore/bwjson"
	bwtesting "github.com/baza-winner/bwcore/bwtesting"
	"testing"
)

func TestInterface(t *testing.T) {
	bwtesting.BwRunTests(t, InterfaceFrom, map[string]bwtesting.Case{"InterfaceFrom": {
		In: []interface{}{_InterfaceTestItemA, _InterfaceTestItemB},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, InterfaceFromSlice, map[string]bwtesting.Case{"InterfaceFromSlice": {
		In: []interface{}{[]interface{}{_InterfaceTestItemA, _InterfaceTestItemB}},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, InterfaceFromSet, map[string]bwtesting.Case{"InterfaceFromSet": {
		In: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Interface.Copy, map[string]bwtesting.Case{"Interface.Copy": {
		In: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Interface.ToSlice, map[string]bwtesting.Case{"Interface.ToSlice": {
		In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
		Out: []interface{}{[]interface{}{_InterfaceTestItemA}},
	}})
	bwtesting.BwRunTests(t, Interface.String, map[string]bwtesting.Case{"Interface.String": {
		In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
		Out: []interface{}{func() string {
			result, _ := json.Marshal(_InterfaceTestItemA)
			return "[" + string(result) + "]"
		}()},
	}})
	bwtesting.BwRunTests(t, Interface.MarshalJSON, map[string]bwtesting.Case{"Interface.MarshalJSON": {
		In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
		Out: []interface{}{(func() []byte {
			result, _ := json.Marshal([]interface{}{_InterfaceTestItemA})
			return result
		})(), nil},
	}})
	bwtesting.BwRunTests(t, Interface.ToSliceOfStrings, map[string]bwtesting.Case{"Interface.ToSliceOfStrings": {
		In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
		Out: []interface{}{[]string{bwjson.Pretty(_InterfaceTestItemA)}},
	}})
	bwtesting.BwRunTests(t, Interface.Has, map[string]bwtesting.Case{
		"Interface.Has: false": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, _InterfaceTestItemB},
			Out: []interface{}{false},
		},
		"Interface.Has: true": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, _InterfaceTestItemA},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Interface.HasAny, map[string]bwtesting.Case{
		"Interface.HasAny: empty": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
			Out: []interface{}{false},
		},
		"Interface.HasAny: false": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, _InterfaceTestItemB},
			Out: []interface{}{false},
		},
		"Interface.HasAny: true": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, _InterfaceTestItemA, _InterfaceTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Interface.HasAnyOfSlice, map[string]bwtesting.Case{
		"Interface.HasAnyOfSlice: empty": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, []interface{}{}},
			Out: []interface{}{false},
		},
		"Interface.HasAnyOfSlice: false": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, []interface{}{_InterfaceTestItemB}},
			Out: []interface{}{false},
		},
		"Interface.HasAnyOfSlice: true": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, []interface{}{_InterfaceTestItemA, _InterfaceTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Interface.HasAnyOfSet, map[string]bwtesting.Case{
		"Interface.HasAnyOfSet: empty": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, Interface{}},
			Out: []interface{}{false},
		},
		"Interface.HasAnyOfSet: false": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, Interface{_InterfaceTestItemB: struct{}{}}},
			Out: []interface{}{false},
		},
		"Interface.HasAnyOfSet: true": {
			In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, Interface{
				_InterfaceTestItemA: struct{}{},
				_InterfaceTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Interface.HasEach, map[string]bwtesting.Case{
		"Interface.HasEach: empty": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
			Out: []interface{}{true},
		},
		"Interface.HasEach: false": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, _InterfaceTestItemA, _InterfaceTestItemB},
			Out: []interface{}{false},
		},
		"Interface.HasEach: true": {
			In: []interface{}{Interface{
				_InterfaceTestItemA: struct{}{},
				_InterfaceTestItemB: struct{}{},
			}, _InterfaceTestItemA, _InterfaceTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Interface.HasEachOfSlice, map[string]bwtesting.Case{
		"Interface.HasEachOfSlice: empty": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, []interface{}{}},
			Out: []interface{}{true},
		},
		"Interface.HasEachOfSlice: false": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, []interface{}{_InterfaceTestItemA, _InterfaceTestItemB}},
			Out: []interface{}{false},
		},
		"Interface.HasEachOfSlice: true": {
			In: []interface{}{Interface{
				_InterfaceTestItemA: struct{}{},
				_InterfaceTestItemB: struct{}{},
			}, []interface{}{_InterfaceTestItemA, _InterfaceTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Interface.HasEachOfSet, map[string]bwtesting.Case{
		"Interface.HasEachOfSet: empty": {
			In:  []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, Interface{}},
			Out: []interface{}{true},
		},
		"Interface.HasEachOfSet: false": {
			In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, Interface{
				_InterfaceTestItemA: struct{}{},
				_InterfaceTestItemB: struct{}{},
			}},
			Out: []interface{}{false},
		},
		"Interface.HasEachOfSet: true": {
			In: []interface{}{Interface{
				_InterfaceTestItemA: struct{}{},
				_InterfaceTestItemB: struct{}{},
			}, Interface{
				_InterfaceTestItemA: struct{}{},
				_InterfaceTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Interface._AddTestHelper, map[string]bwtesting.Case{"Interface.Add": {
		In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, _InterfaceTestItemB},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Interface._AddSliceTestHelper, map[string]bwtesting.Case{"Interface.AddSlice": {
		In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, []interface{}{_InterfaceTestItemB}},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Interface._AddSetTestHelper, map[string]bwtesting.Case{"Interface.AddSet": {
		In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, Interface{_InterfaceTestItemB: struct{}{}}},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Interface._DelTestHelper, map[string]bwtesting.Case{"Interface.Del": {
		In: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}, _InterfaceTestItemB},
		Out: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Interface._DelSliceTestHelper, map[string]bwtesting.Case{"Interface.DelSlice": {
		In: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}, []interface{}{_InterfaceTestItemB}},
		Out: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Interface._DelSetTestHelper, map[string]bwtesting.Case{"Interface.DelSet": {
		In: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}, Interface{_InterfaceTestItemB: struct{}{}}},
		Out: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Interface.Union, map[string]bwtesting.Case{"Interface.Union": {
		In: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}, Interface{_InterfaceTestItemB: struct{}{}}},
		Out: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Interface.Intersect, map[string]bwtesting.Case{"Interface.Intersect": {
		In: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}, Interface{_InterfaceTestItemB: struct{}{}}},
		Out: []interface{}{Interface{_InterfaceTestItemB: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Interface.Subtract, map[string]bwtesting.Case{"Interface.Subtract": {
		In: []interface{}{Interface{
			_InterfaceTestItemA: struct{}{},
			_InterfaceTestItemB: struct{}{},
		}, Interface{_InterfaceTestItemB: struct{}{}}},
		Out: []interface{}{Interface{_InterfaceTestItemA: struct{}{}}},
	}})
}

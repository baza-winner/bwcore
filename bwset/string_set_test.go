// Code generated by "bwsetter -type=string"; DO NOT EDIT; bwsetter: go get -type=string -set=String -test%!(EXTRA string=github.com/baza-winner/bwcore/bwsetter)

package bwset

import (
	"encoding/json"
	bwtesting "github.com/baza-winner/bwcore/bwtesting"
	"testing"
)

func TestString(t *testing.T) {
	bwtesting.BwRunTests(t, StringFrom, map[string]bwtesting.Case{"StringFrom": {
		In: []interface{}{_StringTestItemA, _StringTestItemB},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, StringFromSlice, map[string]bwtesting.Case{"StringFromSlice": {
		In: []interface{}{[]string{_StringTestItemA, _StringTestItemB}},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, StringFromSet, map[string]bwtesting.Case{"StringFromSet": {
		In: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, String.Copy, map[string]bwtesting.Case{"String.Copy": {
		In: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, String.ToSlice, map[string]bwtesting.Case{"String.ToSlice": {
		In:  []interface{}{String{_StringTestItemA: struct{}{}}},
		Out: []interface{}{[]string{_StringTestItemA}},
	}})
	bwtesting.BwRunTests(t, _StringToSliceTestHelper, map[string]bwtesting.Case{"_StringToSliceTestHelper": {
		In:  []interface{}{[]string{_StringTestItemB, _StringTestItemA}},
		Out: []interface{}{[]string{_StringTestItemA, _StringTestItemB}},
	}})
	bwtesting.BwRunTests(t, String.String, map[string]bwtesting.Case{"String.String": {
		In: []interface{}{String{_StringTestItemA: struct{}{}}},
		Out: []interface{}{func() string {
			result, _ := json.Marshal(_StringTestItemA)
			return "[" + string(result) + "]"
		}()},
	}})
	bwtesting.BwRunTests(t, String.MarshalJSON, map[string]bwtesting.Case{"String.MarshalJSON": {
		In: []interface{}{String{_StringTestItemA: struct{}{}}},
		Out: []interface{}{(func() []byte {
			result, _ := json.Marshal([]interface{}{_StringTestItemA})
			return result
		})(), nil},
	}})
	bwtesting.BwRunTests(t, String.ToSliceOfStrings, map[string]bwtesting.Case{"String.ToSliceOfStrings": {
		In:  []interface{}{String{_StringTestItemA: struct{}{}}},
		Out: []interface{}{[]string{_StringTestItemA}},
	}})
	bwtesting.BwRunTests(t, String.Has, map[string]bwtesting.Case{
		"String.Has: false": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, _StringTestItemB},
			Out: []interface{}{false},
		},
		"String.Has: true": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, _StringTestItemA},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, String.HasAny, map[string]bwtesting.Case{
		"String.HasAny: empty": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}},
			Out: []interface{}{false},
		},
		"String.HasAny: false": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, _StringTestItemB},
			Out: []interface{}{false},
		},
		"String.HasAny: true": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, _StringTestItemA, _StringTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, String.HasAnyOfSlice, map[string]bwtesting.Case{
		"String.HasAnyOfSlice: empty": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, []string{}},
			Out: []interface{}{false},
		},
		"String.HasAnyOfSlice: false": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, []string{_StringTestItemB}},
			Out: []interface{}{false},
		},
		"String.HasAnyOfSlice: true": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, []string{_StringTestItemA, _StringTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, String.HasAnyOfSet, map[string]bwtesting.Case{
		"String.HasAnyOfSet: empty": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, String{}},
			Out: []interface{}{false},
		},
		"String.HasAnyOfSet: false": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, String{_StringTestItemB: struct{}{}}},
			Out: []interface{}{false},
		},
		"String.HasAnyOfSet: true": {
			In: []interface{}{String{_StringTestItemA: struct{}{}}, String{
				_StringTestItemA: struct{}{},
				_StringTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, String.HasEach, map[string]bwtesting.Case{
		"String.HasEach: empty": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}},
			Out: []interface{}{true},
		},
		"String.HasEach: false": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, _StringTestItemA, _StringTestItemB},
			Out: []interface{}{false},
		},
		"String.HasEach: true": {
			In: []interface{}{String{
				_StringTestItemA: struct{}{},
				_StringTestItemB: struct{}{},
			}, _StringTestItemA, _StringTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, String.HasEachOfSlice, map[string]bwtesting.Case{
		"String.HasEachOfSlice: empty": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, []string{}},
			Out: []interface{}{true},
		},
		"String.HasEachOfSlice: false": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, []string{_StringTestItemA, _StringTestItemB}},
			Out: []interface{}{false},
		},
		"String.HasEachOfSlice: true": {
			In: []interface{}{String{
				_StringTestItemA: struct{}{},
				_StringTestItemB: struct{}{},
			}, []string{_StringTestItemA, _StringTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, String.HasEachOfSet, map[string]bwtesting.Case{
		"String.HasEachOfSet: empty": {
			In:  []interface{}{String{_StringTestItemA: struct{}{}}, String{}},
			Out: []interface{}{true},
		},
		"String.HasEachOfSet: false": {
			In: []interface{}{String{_StringTestItemA: struct{}{}}, String{
				_StringTestItemA: struct{}{},
				_StringTestItemB: struct{}{},
			}},
			Out: []interface{}{false},
		},
		"String.HasEachOfSet: true": {
			In: []interface{}{String{
				_StringTestItemA: struct{}{},
				_StringTestItemB: struct{}{},
			}, String{
				_StringTestItemA: struct{}{},
				_StringTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, String._AddTestHelper, map[string]bwtesting.Case{"String.Add": {
		In: []interface{}{String{_StringTestItemA: struct{}{}}, _StringTestItemB},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, String._AddSliceTestHelper, map[string]bwtesting.Case{"String.AddSlice": {
		In: []interface{}{String{_StringTestItemA: struct{}{}}, []string{_StringTestItemB}},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, String._AddSetTestHelper, map[string]bwtesting.Case{"String.AddSet": {
		In: []interface{}{String{_StringTestItemA: struct{}{}}, String{_StringTestItemB: struct{}{}}},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, String._DelTestHelper, map[string]bwtesting.Case{"String.Del": {
		In: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}, _StringTestItemB},
		Out: []interface{}{String{_StringTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, String._DelSliceTestHelper, map[string]bwtesting.Case{"String.DelSlice": {
		In: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}, []string{_StringTestItemB}},
		Out: []interface{}{String{_StringTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, String._DelSetTestHelper, map[string]bwtesting.Case{"String.DelSet": {
		In: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}, String{_StringTestItemB: struct{}{}}},
		Out: []interface{}{String{_StringTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, String.Union, map[string]bwtesting.Case{"String.Union": {
		In: []interface{}{String{_StringTestItemA: struct{}{}}, String{_StringTestItemB: struct{}{}}},
		Out: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, String.Intersect, map[string]bwtesting.Case{"String.Intersect": {
		In: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}, String{_StringTestItemB: struct{}{}}},
		Out: []interface{}{String{_StringTestItemB: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, String.Subtract, map[string]bwtesting.Case{"String.Subtract": {
		In: []interface{}{String{
			_StringTestItemA: struct{}{},
			_StringTestItemB: struct{}{},
		}, String{_StringTestItemB: struct{}{}}},
		Out: []interface{}{String{_StringTestItemA: struct{}{}}},
	}})
}
